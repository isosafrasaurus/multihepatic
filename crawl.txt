Directory tree (allowed only):
src
fem
├── __init__.py
├── sink.py
├── sub_cubes.py
└── velo.py
tissue
├── __init__.py
├── domain.py
└── geometry.py
├── __init__.py
├── checkpoint.py
├── core.py
├── meshing.py
├── mpl.py
├── plotly.py
├── pressure_drop.py
├── run_study.py
├── run_sweep.py
├── scientific_plots.py
├── util.py
└── vtk.py

=== __init__.py ===
from .core import Domain1D, Domain3D, PhysicsParams, Simulation, SolveResult

=== checkpoint.py ===
import os
import csv
import json
from typing import Dict, Any, Sequence

class CsvWriter:
    @staticmethod
    def write_dict(path: str, d: Dict[str, Any]):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(["name", "value"])
            for k, v in d.items():
                w.writerow([k, v])

    @staticmethod
    def write_rows(path: str, headers: Sequence[str], rows: Sequence[Sequence[Any]]):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w", newline="") as f:
            w = csv.writer(f)
            w.writerow(headers)
            for r in rows:
                w.writerow(r)


class JsonWriter:
    @staticmethod
    def write(path: str, d: Dict[str, Any]):
        os.makedirs(os.path.dirname(path), exist_ok=True)
        with open(path, "w") as f:
            json.dump(d, f, indent=2)


=== core.py ===
import os
import gc
import json
from dataclasses import dataclass
from typing import Optional, Sequence, Tuple, Type, Any, Dict

import numpy as np
from dolfin import Mesh

from .tissue import get_Omega_rect, get_Omega_rect_from_res
from .meshing import get_fg_from_json
from .fem import Sink, Velo, SubCubes
from .checkpoint import CsvWriter


class Domain1D:
    """
    Wraps a FenicsGraph and its line mesh/submeshes.
    Ensures mesh/submesh creation and provides a 'with' lifecycle for cleanup.
    """
    def __init__(self, G, Lambda_num_nodes_exp: int = 5, inlet_nodes: Optional[Sequence[int]] = None):
        self.G = G
        self.Lambda_num_nodes_exp = Lambda_num_nodes_exp
        self.inlet_nodes = list(inlet_nodes) if inlet_nodes is not None else None

    @classmethod
    def from_json(cls, directory: str, Lambda_num_nodes_exp: int = 5, inlet_nodes: Optional[Sequence[int]] = None):
        G = get_fg_from_json(directory)
        # Build/ensure 1D mesh and submeshes
        if not getattr(G, "mesh", None):
            # Assumes graphnics.FenicsGraph exposes make_mesh(num_nodes_exp=...)
            G.make_mesh(num_nodes_exp=Lambda_num_nodes_exp)
        # Ensure per-edge submeshes and tangents exist
        has_submesh = any(("submesh" in G.edges[e]) for e in G.edges)
        if not has_submesh and hasattr(G, "make_submeshes"):
            G.make_submeshes()
        has_tangent = all(("tangent" in G.edges[e]) for e in G.edges) if len(G.edges) > 0 else True
        if not has_tangent and hasattr(G, "compute_tangents"):
            G.compute_tangents()
        return cls(G, Lambda_num_nodes_exp, inlet_nodes)

    @property
    def Lambda(self) -> Mesh:
        return self.G.mesh

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, tb):
        self.dispose()

    def dispose(self):
        # Release per-edge heavy references
        try:
            for e in list(self.G.edges):
                self.G.edges[e].pop("submesh", None)
                self.G.edges[e].pop("tangent", None)
        except Exception:
            pass
        # Drop the 1D mesh reference
        if hasattr(self.G, "mesh"):
            self.G.mesh = None
        gc.collect()


class Domain3D:
    """
    Wraps the 3D tissue mesh Omega and construction bounds.
    """
    def __init__(self, Omega: Mesh, bounds: Sequence[np.ndarray]):
        self.Omega = Omega
        self.bounds = bounds

    @classmethod
    def from_graph(cls, G, bounds: Optional[Sequence[np.ndarray]] = None,
                   voxel_res: Optional[float] = None, voxel_dim: Tuple[int, int, int] = (16, 16, 16),
                   padding: float = 8e-3):
        if voxel_res is not None:
            Omega, bounds = get_Omega_rect_from_res(G, bounds=bounds, voxel_res=voxel_res, padding=padding)
        else:
            Omega, bounds = get_Omega_rect(G, bounds=bounds, voxel_dim=voxel_dim, padding=padding)
        return cls(Omega, bounds)

    def __enter__(self):
        return self

    def __exit__(self, exc_type, exc, tb):
        self.dispose()

    def dispose(self):
        self.Omega = None
        gc.collect()


@dataclass
class PhysicsParams:
    gamma: float
    gamma_a: float
    gamma_R: float
    mu: float
    k_t: float
    P_in: float
    P_cvp: float


@dataclass
class SolveResult:
    uh3d: Any
    uh1d: Any
    velocity: Optional[Any] = None
    extras: Optional[Dict[str, float]] = None

    def free_fields(self):
        self.uh3d = None
        self.uh1d = None
        self.velocity = None
        gc.collect()


class Simulation:
    """
    Orchestrates fem.Sink/Velo/SubCubes solve and CSV analyses.
    Keeps close to raw FEniCS/xii while providing lifecycle + checkpointing.
    """
    def __init__(self, Lambda: Domain1D, Omega: Domain3D,
                 problem_cls: Type[Sink] = Sink,
                 out_dir: Optional[str] = None,
                 lower_cube_bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None,
                 upper_cube_bounds: Optional[Tuple[np.ndarray, np.ndarray]] = None):
        self.Lambda = Lambda
        self.Omega = Omega
        self.out_dir = out_dir

        if problem_cls is SubCubes:
            assert lower_cube_bounds is not None and upper_cube_bounds is not None, \
                "SubCubes requires lower_cube_bounds and upper_cube_bounds."
            self.problem = SubCubes(Lambda.G, Omega.Omega,
                                    lower_cube_bounds, upper_cube_bounds,
                                    Lambda_num_nodes_exp=Lambda.Lambda_num_nodes_exp,
                                    Lambda_inlet_nodes=Lambda.inlet_nodes)
        else:
            self.problem = problem_cls(Lambda.G, Omega.Omega,
                                       Lambda_num_nodes_exp=Lambda.Lambda_num_nodes_exp,
                                       Lambda_inlet_nodes=Lambda.inlet_nodes)

    def solve(self, params: PhysicsParams, save_pvd: bool = False) -> SolveResult:
        out = self.out_dir if (self.out_dir and save_pvd) else None

        if isinstance(self.problem, Velo) or isinstance(self.problem, SubCubes):
            uh3d, uh1d, velocity = self.problem.solve(
                params.gamma, params.gamma_a, params.gamma_R,
                params.mu, params.k_t, params.P_in, params.P_cvp,
                directory=out
            )
            return SolveResult(uh3d=uh3d, uh1d=uh1d, velocity=velocity, extras={})
        else:
            uh3d, uh1d = self.problem.solve(
                params.gamma, params.gamma_a, params.gamma_R,
                params.mu, params.k_t, params.P_in, params.P_cvp,
                directory=out
            )
            return SolveResult(uh3d=uh3d, uh1d=uh1d, velocity=None, extras={})

    def save_path_pressure_csv(self, path: Sequence[int], csv_name: str = "path_pressure.csv"):
        from .pressure_drop import get_path_pressure
        df = get_path_pressure(self.Lambda.G, self.problem.uh1d, path)
        if self.out_dir:
            os.makedirs(self.out_dir, exist_ok=True)
            df.to_csv(os.path.join(self.out_dir, csv_name), index=False)
        return df

    def save_fluxes_csv(self, csv_name: str = "fluxes.csv"):
        records = {}
        p = self.problem

        if hasattr(p, "compute_net_flow_sink"):
            records["net_flow_sink"] = float(p.compute_net_flow_sink())
        if hasattr(p, "compute_inflow_sink"):
            records["inflow_sink"] = float(p.compute_inflow_sink())
        if hasattr(p, "compute_outflow_sink"):
            records["outflow_sink"] = float(p.compute_outflow_sink())

        if hasattr(p, "compute_net_flow_all"):
            records["net_flow_all"] = float(p.compute_net_flow_all())

        if isinstance(p, SubCubes):
            records["lower_cube_flux"]     = float(p.compute_lower_cube_flux())
            records["upper_cube_flux"]     = float(p.compute_upper_cube_flux())
            records["lower_cube_flux_in"]  = float(p.compute_lower_cube_flux_in())
            records["lower_cube_flux_out"] = float(p.compute_lower_cube_flux_out())
            records["upper_cube_flux_in"]  = float(p.compute_upper_cube_flux_in())
            records["upper_cube_flux_out"] = float(p.compute_upper_cube_flux_out())

        if self.out_dir and records:
            CsvWriter.write_dict(os.path.join(self.out_dir, csv_name), records)
        return records

    def dispose(self):
        try:
            for name in ("uh3d", "uh1d", "velocity"):
                if hasattr(self.problem, name):
                    setattr(self.problem, name, None)
        except Exception:
            pass
        self.problem = None
        gc.collect()

    def __del__(self):
        self.dispose()

=== fem/__init__.py ===
from .sink import Sink
from .velo import Velo
from .sub_cubes import SubCubes

=== fem/sink.py ===
import os
import numpy as np

from ..tissue import AveragingRadius, SegmentLength, BoundaryPoint
from dolfin import (FunctionSpace, TrialFunction, TestFunction, Constant, inner, grad,
                    DirichletBC, LUSolver, UserExpression, Point, File, SubDomain,
                    MeshFunction, Measure, UnitCubeMesh, facets, near, DOLFIN_EPS,
                    as_backend_type)
from xii import ii_assemble, apply_bc, ii_convert, ii_Function, Circle, Average
from graphnics import TubeFile

class Sink:
    def __init__(self, G, Omega, Lambda_num_nodes_exp=5, Lambda_inlet_nodes=None,
                 Omega_sink_subdomain=None, order=2):
        # Set constants and placeholders
        self.G = G
        self.Omega = Omega
        Lambda = G.mesh
        self.c_gamma = Constant(0.0)
        self.c_gamma_a = Constant(0.0)
        self.c_gamma_R = Constant(0.0)
        self.c_mu = Constant(0.0)
        self.c_k_t = Constant(0.0)
        self.c_P_in = Constant(0.0)
        self.c_P_cvp = Constant(0.0)

        # Initialize spaces
        boundary_Omega = MeshFunction("size_t", Omega, Omega.topology().dim() - 1, 0)
        boundary_Lambda = MeshFunction("size_t", Lambda, Lambda.topology().dim() - 1, 0)

        # Initialize domains and subdomains
        self.dsOmega = Measure("ds", domain=Omega, subdomain_data=boundary_Omega)
        if Omega_sink_subdomain is not None:
            Omega_sink_subdomain.mark(boundary_Omega, 1)
        if Lambda_inlet_nodes is not None:
            Lambda_coords = Lambda.coordinates()
            for node_id in Lambda_inlet_nodes:
                coordinate = Lambda_coords[node_id]
                inlet_subdomain = BoundaryPoint(coordinate)
                inlet_subdomain.mark(boundary_Lambda, 1)
        self.dsLambda = Measure("ds", domain=Lambda, subdomain_data=boundary_Lambda)
        self.dxOmega = Measure("dx", domain=Omega)
        self.dxLambda = Measure("dx", domain=Lambda)
        self.dsOmegaNeumann = self.dsOmega(0)
        self.dsOmegaSink = self.dsOmega(1)
        self.dsLambdaRobin = self.dsLambda(0)
        self.dsLambdaInlet = self.dsLambda(1)

        # Build bboxtree and network-related averaging measures
        tree = Lambda.bounding_box_tree()
        tree.build(Lambda)
        radius = AveragingRadius(tree, G, degree=order)
        segment_length = SegmentLength(tree, G, degree=order)
        circle = Circle(radius=radius, degree=order)

        # Initialize spaces and system forms
        V3 = FunctionSpace(Omega, "CG", 1)
        V1 = FunctionSpace(Lambda, "CG", 1)
        self.W = [V3, V1]
        u3, u1 = map(TrialFunction, (V3, V1))
        v3, v1 = map(TestFunction, (V3, V1))
        u3_avg = Average(u3, Lambda, circle)
        v3_avg = Average(v3, Lambda, circle)
        D_area = Constant(np.pi) * radius ** 2
        D_perimeter = Constant(2.0 * np.pi) * radius
        k_v_expr = (segment_length * radius ** 2) / Constant(8.0)

        # Initialize systems
        a00 = (
            (self.c_k_t / self.c_mu) * inner(grad(u3), grad(v3)) * self.dxOmega
            + self.c_gamma_R * u3 * v3 * self.dsOmegaSink
            + self.c_gamma * u3_avg * v3_avg * D_perimeter * self.dxLambda
        )
        a01 = (
            - self.c_gamma * u1 * v3_avg * D_perimeter * self.dxLambda
            - (self.c_gamma_a / self.c_mu) * u1 * v3_avg * D_area * self.dsLambdaRobin
        )
        a10 = (
            - self.c_gamma * u3_avg * v1 * D_perimeter * self.dxLambda
        )
        a11 = (
            (k_v_expr / self.c_mu) * D_area * inner(grad(u1), grad(v1)) * self.dxLambda
            + self.c_gamma * u1 * v1 * D_perimeter * self.dxLambda
            + (self.c_gamma_a / self.c_mu) * u1 * v1 * D_area * self.dsLambdaRobin
        )
        L0 = (
            self.c_gamma_R * self.c_P_cvp * v3 * self.dsOmegaSink
            + (self.c_gamma_a * self.c_P_cvp / self.c_mu) * v3_avg * D_area * self.dsLambdaRobin
        )
        L1 = (
            (self.c_gamma_a * self.c_P_cvp / self.c_mu) * v1 * D_area * self.dsLambdaRobin
        )
        self.inlet_bc = DirichletBC(V1, self.c_P_in, boundary_Lambda, 1)
        self.a_forms = [[a00, a01], [a10, a11]]
        self.L_forms = [L0, L1]

        # Attributes for solutions
        self.uh3d = None
        self.uh1d = None

    def solve(self, gamma, gamma_a, gamma_R, mu, k_t, P_in, P_cvp, directory=None):
        # Assign constants
        self.c_gamma.assign(gamma)
        self.c_gamma_a.assign(gamma_a)
        self.c_gamma_R.assign(gamma_R)
        self.c_mu.assign(mu)
        self.c_k_t.assign(k_t)
        self.c_P_in.assign(P_in)
        self.c_P_cvp.assign(P_cvp)

        # Assemble and solve system
        A, b = map(ii_assemble, (self.a_forms, self.L_forms))
        inlet_bcs = [self.inlet_bc] if self.inlet_bc.get_boundary_values() else []
        W_bcs = [[], inlet_bcs]
        if inlet_bcs:
            A, b = apply_bc(A, b, W_bcs)
        else:
            raise ValueError("No Dirichlet conditions")
        A, b = map(ii_convert, (A, b))
        wh = ii_Function(self.W)
        solver = LUSolver(A, "mumps")
        solver.solve(wh.vector(), b)
        del solver  # free solver promptly

        self.uh3d, self.uh1d = wh
        self.uh3d.rename("3D Pressure (Pa)", "3D Pressure Distribution")
        self.uh1d.rename("1D Pressure (Pa)", "1D Pressure Distribution")

        # Save to file
        if directory is not None:
            os.makedirs(directory, exist_ok=True)
            TubeFile(self.G, os.path.join(directory, "pressure1d.pvd")) << self.uh1d
            File(os.path.join(directory, "pressure3d.pvd")) << self.uh3d

        # Explicit PETSc cleanup (best-effort)
        try:
            as_backend_type(A).mat().destroy()
            as_backend_type(b).vec().destroy()
        except Exception:
            pass
        A = None
        b = None

        return self.uh3d, self.uh1d


=== fem/sub_cubes.py ===
import os
import numpy as np
from dolfin import SubDomain, MeshFunction, Measure, FacetNormal, conditional, lt, gt, dot, avg, assemble
from .velo import Velo
from ..tissue import CubeSubBoundary

class SubCubes(Velo):
    def __init__(self, G, Omega, lower_cube_bounds, upper_cube_bounds,
                 Lambda_num_nodes_exp=5,
                 Lambda_inlet_nodes=None,
                 Omega_sink_subdomain=None,
                 order=2):
        super().__init__(G, Omega, Lambda_num_nodes_exp, Lambda_inlet_nodes, Omega_sink_subdomain, order)
        self.lower_boundaries = MeshFunction("size_t", self.Omega, self.Omega.topology().dim() - 1, 0)
        self.upper_boundaries = MeshFunction("size_t", self.Omega, self.Omega.topology().dim() - 1, 0)
        self.lower_cube = CubeSubBoundary(lower_cube_bounds[0], lower_cube_bounds[1])
        self.upper_cube = CubeSubBoundary(upper_cube_bounds[0], upper_cube_bounds[1])
        self.lower_cube.mark(self.lower_boundaries, 1)
        self.upper_cube.mark(self.upper_boundaries, 1)
        self.dS_lower = Measure("dS", domain=self.Omega, subdomain_data=self.lower_boundaries)
        self.dS_upper = Measure("dS", domain=self.Omega, subdomain_data=self.upper_boundaries)

    def solve(self, gamma, gamma_a, gamma_R, mu, k_t, P_in, P_cvp, directory=None):
        return super().solve(gamma, gamma_a, gamma_R, mu, k_t, P_in, P_cvp, directory=directory)

    def compute_lower_cube_flux(self):
        n = FacetNormal(self.Omega)
        return assemble(dot(avg(self.velocity), n('-')) * self.dS_lower(1))

    def compute_upper_cube_flux(self):
        n = FacetNormal(self.Omega)
        return assemble(dot(avg(self.velocity), n('-')) * self.dS_upper(1))

    def compute_lower_cube_flux_in(self):
        n = FacetNormal(self.Omega)
        expr = conditional(
            lt(dot(avg(self.velocity), n('-')), 0),
            dot(avg(self.velocity), n('-')),
            0.0
        )
        return assemble(expr * self.dS_lower(1))

    def compute_lower_cube_flux_out(self):
        n = FacetNormal(self.Omega)
        expr = conditional(
            gt(dot(avg(self.velocity), n('-')), 0),
            dot(avg(self.velocity), n('-')),
            0.0
        )
        return assemble(expr * self.dS_lower(1))

    def compute_upper_cube_flux_in(self):
        n = FacetNormal(self.Omega)
        expr = conditional(
            lt(dot(avg(self.velocity), n('-')), 0),
            dot(avg(self.velocity), n('-')),
            0.0
        )
        return assemble(expr * self.dS_upper(1))

    def compute_upper_cube_flux_out(self):
        n = FacetNormal(self.Omega)
        expr = conditional(
            gt(dot(avg(self.velocity), n('-')), 0),
            dot(avg(self.velocity), n('-')),
            0.0
        )
        return assemble(expr * self.dS_upper(1))


=== fem/velo.py ===
import os
import numpy as np
from dolfin import VectorFunctionSpace, Function, TrialFunction, TestFunction, Constant, inner, grad, FacetNormal, \
    conditional, lt, gt, dot, assemble, solve, File
from .sink import Sink

class Velo(Sink):
    def __init__(self, G, Omega, Lambda_num_nodes_exp=5, Lambda_inlet_nodes=None, Omega_sink_subdomain=None, order=2):
        super().__init__(G, Omega, Lambda_num_nodes_exp, Lambda_inlet_nodes, Omega_sink_subdomain, order)
        self.k_t = None
        self.mu = None
        self.velocity = None

    def solve(self, gamma, gamma_a, gamma_R, mu, k_t, P_in, P_cvp, directory=None):
        uh3d, uh1d = super().solve(gamma, gamma_a, gamma_R, mu, k_t, P_in, P_cvp, directory=directory)

        # Set constants
        self.k_t = k_t
        self.mu = mu

        # Initialize spaces, solve projection
        V_vec = VectorFunctionSpace(self.Omega, "CG", 1)
        v_trial = TrialFunction(V_vec)
        v_test = TestFunction(V_vec)
        a_proj = inner(v_trial, v_test) * self.dxOmega
        L_proj = inner(Constant(-self.k_t/self.mu) * grad(self.uh3d), v_test) * self.dxOmega
        velocity = Function(V_vec)
        solve(a_proj == L_proj, velocity, solver_parameters={"linear_solver": "mumps"})
        velocity.rename("3D Velocity (m/s)", "3D Velocity Distribution")
        self.velocity = velocity

        # Save to file
        if directory is not None:
            os.makedirs(directory, exist_ok=True)
            File(os.path.join(directory, "velocity3d.pvd")) << self.velocity

        return uh3d, uh1d, self.velocity

    def compute_inflow_sink(self):
        n = FacetNormal(self.Omega)
        expr = conditional(lt(dot(self.velocity, n), 0), dot(self.velocity, n), 0.0)
        return assemble(expr * self.dsOmegaSink)

    def compute_outflow_sink(self):
        n = FacetNormal(self.Omega)
        expr = conditional(gt(dot(self.velocity, n), 0), dot(self.velocity, n), 0.0)
        return assemble(expr * self.dsOmegaSink)

    def compute_net_flow_sink(self):
        return self.compute_inflow_sink() + self.compute_outflow_sink()

    def compute_net_flow_sink_dolfin(self):
        n = FacetNormal(self.Omega)
        return assemble(dot(self.velocity, n) * self.dsOmegaSink)

    def compute_inflow_all(self):
        n = FacetNormal(self.Omega)
        expr = conditional(lt(dot(self.velocity, n), 0), dot(self.velocity, n), 0.0)
        return assemble(expr * self.dsOmega)

    def compute_outflow_all(self):
        n = FacetNormal(self.Omega)
        expr = conditional(gt(dot(self.velocity, n), 0), dot(self.velocity, n), 0.0)
        return assemble(expr * self.dsOmega)

    def compute_net_flow_all(self):
        return self.compute_inflow_all() + self.compute_outflow_all()

    def compute_net_flow_all_dolfin(self):
        n = FacetNormal(self.Omega)
        return assemble(dot(self.velocity, n) * self.dsOmega)

    def compute_net_flow_neumann_dolfin(self):
        n = FacetNormal(self.Omega)
        return assemble(dot(self.velocity, n) * self.dsOmegaNeumann)


=== meshing.py ===
import os
import json
from graphnics import FenicsGraph

def get_fg_from_json(directory):
    json_files = sorted([
        f for f in os.listdir(directory)
        if f.startswith("Centerline_") and f.endswith(".mrk.json")
    ])
    num_files = len(json_files)
    if num_files == 0:
        raise ValueError(f"No .json files found in {directory}")
    else:
        print(f"Found {num_files} JSON files in '{directory}'.")

    G = FenicsGraph()
    branch_points = {}
    ind = 0
    for idx, file_name in enumerate(json_files):
        file_path = os.path.join(directory, file_name)
        with open(file_path, 'r') as f:
            data = json.load(f)

        points = data['markups'][0]['controlPoints']
        radius = data['markups'][0]['measurements'][3]['controlPointValues']
        G.add_nodes_from(range(ind - idx, ind + len(points) - idx))
        v1 = 0
        for key, val in branch_points.items():
            if points[0]['position'] == val:
                v1 = key
                break

        v2 = ind - idx + 1
        pos_v1 = points[0]['position']
        pos_v2 = points[1]['position']
        G.nodes[v1]["pos"] = pos_v1
        G.nodes[v2]["pos"] = pos_v2
        G.nodes[v1]["radius"] = radius[0]
        G.nodes[v2]["radius"] = radius[1]
        G.add_edge(v1, v2)
        G.edges[v1, v2]["radius"] = (G.nodes[v1]["radius"] + G.nodes[v2]["radius"]) / 2
        for i in range(len(points) - 2):
            v1 = ind - idx + 1 + i
            v2 = v1 + 1
            pos_v1 = points[i + 1]['position']
            pos_v2 = points[i + 2]['position']
            G.nodes[v1]["pos"] = pos_v1
            G.nodes[v2]["pos"] = pos_v2
            G.nodes[v1]["radius"] = radius[i + 1]
            G.nodes[v2]["radius"] = radius[i + 2]
            G.add_edge(v1, v2)
            G.edges[v1, v2]["radius"] = (G.nodes[v1]["radius"] + G.nodes[v2]["radius"]) / 2
        ind += len(points)
        branch_points.update({ind - idx - 1: pos_v2})
    return G


=== mpl.py ===
import numpy as np
import matplotlib.pyplot as plt
from scipy.interpolate import griddata
from matplotlib.patches import Rectangle

from graphnics import *
from xii import *
from .util import *

def set_axes_equal(ax):
    limits = np.array([ax.get_xlim3d(), ax.get_ylim3d(), ax.get_zlim3d()])
    centers = limits.mean(axis=1)
    radius = 0.75 * np.max(limits[:, 1] - limits[:, 0])
    ax.set_xlim3d([centers[0] - radius, centers[0] + radius])
    ax.set_ylim3d([centers[1] - radius, centers[1] + radius])
    ax.set_zlim3d([centers[2] - radius, centers[2] + radius])

def plot_3d_box(ax, box, color, label=None):
    lower, upper = box
    corners = np.array([
        [lower[0], lower[1], lower[2]],
        [upper[0], lower[1], lower[2]],
        [upper[0], upper[1], lower[2]],
        [lower[0], upper[1], lower[2]],
        [lower[0], lower[1], upper[2]],
        [upper[0], lower[1], upper[2]],
        [upper[0], upper[1], upper[2]],
        [lower[0], upper[1], upper[2]]
    ])
    for idx, (i, j) in enumerate(BOX_EDGES):
        kwargs = {'color': color}
        if idx == 0 and label:
            kwargs['label'] = label
        ax.plot([corners[i, 0], corners[j, 0]],
                [corners[i, 1], corners[j, 1]],
                [corners[i, 2], corners[j, 2]], **kwargs)

def plot_with_boundaries(uh1d, uh3d, z_level=None, cube_lower=None, cube_upper=None):
    mesh1d, mesh3d = uh1d.function_space().mesh(), uh3d.function_space().mesh()
    coords1d, coords3d = mesh1d.coordinates(), mesh3d.coordinates()
    values1d, values3d = uh1d.compute_vertex_values(mesh1d), uh3d.compute_vertex_values(mesh3d)

    z_level = z_level or np.median(coords3d[:, 2])
    fig = plt.figure(figsize=(14, 6))

    # 3D scatter of 1D values
    ax1 = fig.add_subplot(1, 2, 1, projection='3d')
    sc = ax1.scatter(coords1d[:, 0], coords1d[:, 1], coords1d[:, 2], c=values1d, cmap='viridis', marker='o')
    fig.colorbar(sc, ax=ax1, label='1D Pressure (Pa)')
    ax1.set(title='1D Pressure Scatter', xlabel='X', ylabel='Y', zlabel='Z')
    set_axes_equal(ax1)

    omega_box, sub_box = compute_boundaries(coords3d), compute_boundaries(coords1d)
    plot_3d_box(ax1, (list(omega_box[::2]), list(omega_box[1::2])), color='red', label='Omega Boundary')
    plot_3d_box(ax1, (list(sub_box[::2]), list(sub_box[1::2])), color='blue', label='Sub-mesh Boundary')
    if cube_lower:
        plot_3d_box(ax1, cube_lower, color='green', label='Lower Cube Subdomain')
    if cube_upper:
        plot_3d_box(ax1, cube_upper, color='magenta', label='Upper Cube Subdomain')
    ax1.legend()

    # 2D heatmap slice at Z = z_level
    tol = 1e-3
    mask = np.abs(coords3d[:, 2] - z_level) < tol
    if not mask.any():
        print(f"No data found at Z={z_level}")
        return fig

    x_slice, y_slice, z_vals = coords3d[mask, 0], coords3d[mask, 1], values3d[mask]
    xi = np.linspace(x_slice.min(), x_slice.max(), 100)
    yi = np.linspace(y_slice.min(), y_slice.max(), 100)
    xi, yi = np.meshgrid(xi, yi)
    zi = griddata((x_slice, y_slice), z_vals, (xi, yi), method='cubic')

    ax2 = fig.add_subplot(1, 2, 2)
    hm = ax2.imshow(zi, extent=(x_slice.min(), x_slice.max(),
                                y_slice.min(), y_slice.max()),
                    origin='lower', cmap='viridis')
    fig.colorbar(hm, ax=ax2, label='3D Pressure (Pa)')
    ax2.set(title=f'3D Pressure Heatmap at Z = {z_level:.3f}', xlabel='X', ylabel='Y')
    ax2.set_aspect('equal', adjustable='box')

    for box, color, label in zip([omega_box, sub_box], ['red', 'blue'], ['Omega Boundary', 'Sub-mesh Boundary']):
        rect = Rectangle((box[0], box[2]), box[1] - box[0], box[3] - box[2],
                         edgecolor=color, facecolor='none', lw=2, label=label)
        ax2.add_patch(rect)
    ax2.legend()

    plt.tight_layout()
    return fig


=== plotly.py ===
import numpy as np
import plotly.graph_objects as go
from typing import Optional, Tuple, Any

from graphnics import *
from xii import *
from .util import *

def add_box_plotly(fig: go.Figure,
                   box: Tuple[np.ndarray, np.ndarray],
                   color: str, name: str) -> None:
    lower, upper = box
    corners = np.array([
        [lower[0], lower[1], lower[2]],
        [upper[0], lower[1], lower[2]],
        [upper[0], upper[1], lower[2]],
        [lower[0], upper[1], lower[2]],
        [lower[0], lower[1], upper[2]],
        [upper[0], lower[1], upper[2]],
        [upper[0], upper[1], upper[2]],
        [lower[0], upper[1], upper[2]]
    ])
    x_line, y_line, z_line = get_box_edges(corners)
    fig.add_trace(go.Scatter3d(
        x=x_line, y=y_line, z=z_line,
        mode='lines',
        line=dict(color=color, width=4),
        name=name
    ))

def plot_with_boundaries_plotly(uh1d: Any, uh3d: Any,
                                cube_lower: Optional[Tuple[np.ndarray, np.ndarray]] = None,
                                cube_upper: Optional[Tuple[np.ndarray, np.ndarray]] = None) -> None:
    mesh1d = uh1d.function_space().mesh()
    coords1d = mesh1d.coordinates()
    values1d = uh1d.compute_vertex_values(mesh1d)
    mesh3d = uh3d.function_space().mesh()
    coords3d = mesh3d.coordinates()

    omega_box = compute_boundaries(coords3d)
    sub_box = compute_boundaries(coords1d)

    fig = go.Figure()

    annotations = [f"({x:.2f}, {y:.2f}, {z:.2f})<br>P: {p:.2e}"
                   for (x, y, z), p in zip(coords1d, values1d)]

    fig.add_trace(go.Scatter3d(
        x=coords1d[:, 0],
        y=coords1d[:, 1],
        z=coords1d[:, 2],
        mode='markers',
        marker=dict(
            size=4,
            color=values1d,
            colorscale='Viridis',
            colorbar=dict(title='1D Pressure (Pa)'),
            opacity=0.8
        ),
        text=annotations,
        textposition="top center",
        name='1D Pressure'
    ))

    add_box_plotly(fig, ([omega_box[0], omega_box[2], omega_box[4]],
                           [omega_box[1], omega_box[3], omega_box[5]]),
                   color='red', name='Omega Boundary')
    add_box_plotly(fig, ([sub_box[0], sub_box[2], sub_box[4]],
                           [sub_box[1], sub_box[3], sub_box[5]]),
                   color='blue', name='Sub-mesh Boundary')
    if cube_lower is not None:
        add_box_plotly(fig, cube_lower, color='green', name='Lower Cube Subdomain')
    if cube_upper is not None:
        add_box_plotly(fig, cube_upper, color='magenta', name='Upper Cube Subdomain')

    fig.update_layout(
        scene=dict(
            xaxis_title='X',
            yaxis_title='Y',
            zaxis_title='Z',
            aspectmode='data'
        ),
        title='1D Pressure Scatter with Boundaries',
        margin=dict(l=0, r=0, b=0, t=40),
        width=1000,
        height=700
    )
    fig.show()


=== pressure_drop.py ===
import os
import numpy as np
import pandas as pd

from graphnics import *
from xii import *
from dolfin import DOLFIN_EPS

def get_cells_along_path(G, path, tolerance=DOLFIN_EPS):
    if not G.mesh:
        raise ValueError("FenicsGraph object meshes not initialized. Call .make_mesh()")

    # List for global vertices
    global_vertices = []
    global_coords = G.mesh.coordinates()

    # For all node pairs in the path
    for i in range(len(path) - 1):
        u, v = path[i], path[i + 1]
        if G.has_edge(u, v):
            edge, forward = (u, v), True
        elif G.has_edge(v, u):
            edge, forward = (v, u), False
        else:
            raise ValueError(f"No edge between {u} and {v} in the graph.")
        if "submesh" not in G.edges[edge]:
            raise ValueError("FenicsGraph object submeshes not initialized. Call .make_submeshes()")
        submesh = G.edges[edge]["submesh"]
        coords = submesh.coordinates()

        # Map local submesh vertex indices to global mesh vertex indices
        if hasattr(submesh, 'entity_map'):
            local_to_global = submesh.entity_map(0)
        else:
            local_to_global = []
            for local_pt in coords:
                matches = np.where(np.all(np.isclose(global_coords, local_pt, atol=tolerance), axis=1))[0]
                if len(matches) == 0:
                    raise ValueError(f"No matching global vertex for local coordinate: {local_pt}")
                local_to_global.append(matches[0])
            local_to_global = np.array(local_to_global)

        # Tangent vector and direction
        tangent = G.edges[edge]["tangent"]
        if not forward:
            tangent = -tangent
        proj = np.dot(coords, tangent)
        sorted_local_indices = np.argsort(proj)

        # Convert sorted local indices to global vertex indices
        ordered_globals = [local_to_global[idx] for idx in sorted_local_indices]
        if i > 0 and ordered_globals[0] == global_vertices[-1]:
            ordered_globals = ordered_globals[1:]
        global_vertices.extend(ordered_globals)
    return global_vertices

def get_path_pressure(G, uh1d, path, directory=None):
    node_ids = get_cells_along_path(G, path)
    mesh = uh1d.function_space().mesh()
    coords = mesh.coordinates()
    pressure = uh1d.compute_vertex_values(mesh)
    path_coords, path_pressure = coords[node_ids], pressure[node_ids]
    culum_dist = np.concatenate(([0], np.cumsum(np.linalg.norm(np.diff(path_coords, axis=0), axis=1))))

    df = pd.DataFrame({"culum_dist": culum_dist, "path_pressure": path_pressure})
    if directory is not None:
        os.makedirs(directory, exist_ok=True)
        df.to_csv(directory, index=False)
    return df


=== run_study.py ===
from src.core import Domain1D, Domain3D, PhysicsParams, Simulation
from src.fem import Velo

json_dir = "/path/to/jsons"
out_dir  = "/tmp/run1"

with Domain1D.from_json(json_dir, Lambda_num_nodes_exp=5, inlet_nodes=[0]) as Lambda:
    with Domain3D.from_graph(Lambda.G, voxel_res=1e-3, padding=8e-3) as Omega:
        params = PhysicsParams(
            gamma=1.0, gamma_a=1.0, gamma_R=0.0,
            mu=3.5e-3, k_t=1.0e-14, P_in=1000.0, P_cvp=0.0
        )
        sim = Simulation(Lambda, Omega, problem_cls=Velo, out_dir=out_dir)

        # Solve and save fields (PVD) if desired
        result = sim.solve(params, save_pvd=True)

        # Example CSV checkpoints for plotting later (no FEniCS needed)
        sim.save_path_pressure_csv(path=[0, 1, 2, 5, 9], csv_name="path_pressure.csv")
        sim.save_fluxes_csv(csv_name="fluxes.csv")

        # If you don't need the solutions in memory after writing, free them explicitly
        result.free_fields()
        sim.dispose()

=== run_sweep.py ===
from src.core import Domain1D, Domain3D, PhysicsParams, Simulation
from src.fem import Sink

json_dir = "/path/to/jsons"
out_root = "/tmp/sweep"

gammas = [0.5, 1.0, 2.0]
mus    = [3.0e-3, 3.5e-3, 4.0e-3]

for gi, gamma in enumerate(gammas):
    for mi, mu in enumerate(mus):
        out_dir = f"{out_root}/g{gi}_m{mi}"
        with Domain1D.from_json(json_dir, Lambda_num_nodes_exp=5, inlet_nodes=[0]) as Lambda:
            with Domain3D.from_graph(Lambda.G, voxel_res=1e-3, padding=8e-3) as Omega:
                params = PhysicsParams(gamma, 1.0, 0.0, mu, 1.0e-14, 1500.0, 0.0)
                sim = Simulation(Lambda, Omega, problem_cls=Sink, out_dir=out_dir)

                res = sim.solve(params, save_pvd=False)
                sim.save_fluxes_csv(csv_name="fluxes.csv")  # scalar results for quick QA
                res.free_fields()
                sim.dispose()


=== scientific_plots.py ===
import os
import pandas as pd
import matplotlib.pyplot as plt

def plot_path_pressure_csv(csv_path: str, out_png: str = None):
    """
    Load 'culum_dist' vs 'path_pressure' CSV and plot a quick line chart.
    """
    df = pd.read_csv(csv_path)
    fig, ax = plt.subplots(figsize=(6, 4))
    ax.plot(df["culum_dist"], df["path_pressure"], linewidth=2)
    ax.set_xlabel("Cumulative distance (m)")
    ax.set_ylabel("Pressure (Pa)")
    ax.set_title("Path Pressure")
    ax.grid(True, alpha=0.3)
    plt.tight_layout()
    if out_png:
        os.makedirs(os.path.dirname(out_png), exist_ok=True)
        fig.savefig(out_png, dpi=200)
    return fig, ax


=== tissue/__init__.py ===
from .domain import AveragingRadius, SegmentLength, get_Omega_rect, get_Omega_rect_from_res
from .geometry import AxisPlane, BoundaryPoint, CubeSubBoundary


=== tissue/domain.py ===
import numpy as np
from dolfin import SubDomain, MeshFunction, Measure, UnitCubeMesh, facets, near, UserExpression, DOLFIN_EPS, Point
from .geometry import BoundaryPoint

class AveragingRadius(UserExpression):
    def __init__(self, tree, G, **kwargs):
        super().__init__(**kwargs)
        self.tree = tree
        self.G = G
    def eval(self, value, x):
        p = Point(x[0], x[1], x[2])
        cell = self.tree.compute_first_entity_collision(p)
        if cell == np.iinfo(np.uint32).max:
            value[0] = 0.0
        else:
            edge_ix = self.G.mf[cell]
            edge = list(self.G.edges())[edge_ix]
            value[0] = self.G.edges()[edge]['radius']

class SegmentLength(UserExpression):
    def __init__(self, tree, G, **kwargs):
        super().__init__(**kwargs)
        self.tree = tree
        self.G = G
    def eval(self, value, x):
        p = Point(*x)
        cell = self.tree.compute_first_entity_collision(p)
        if cell == np.iinfo(np.uint32).max:
            value[0] = 0.0
            return
        edge_ix = self.G.mf[cell]
        edge = list(self.G.edges())[edge_ix]
        u, v = edge
        pos_u = np.array(self.G.nodes[u]['pos'])
        pos_v = np.array(self.G.nodes[v]['pos'])
        length = np.linalg.norm(pos_v - pos_u)
        value[0] = float(length)

def get_Omega_rect(G, bounds=None, voxel_dim=(16, 16, 16), padding=0.008):
    positions = [data['pos'] for node, data in G.nodes(data=True)]
    pos_array = np.array(positions)
    Lambda_min = np.min(pos_array, axis=0)
    Lambda_max = np.max(pos_array, axis=0)
    if bounds is None:
        scales = Lambda_max - Lambda_min + 2 * padding
        shifts = Lambda_min - padding
        bounds = [shifts, shifts + scales]
    else:
        lower, upper = np.min(bounds, axis=0), np.max(bounds, axis=0)
        if not (np.all(Lambda_min >= lower) and np.all(Lambda_max <= upper)):
            raise ValueError("Lambda is not contained within the provided bounds.")
        scales = upper - lower
        shifts = lower
    Omega = UnitCubeMesh(*voxel_dim)
    Omega_coords = Omega.coordinates()
    Omega_coords[:] = Omega_coords * scales + shifts
    return Omega, bounds

def get_Omega_rect_from_res(G, bounds=None, voxel_res=0.001, padding=0.008):
    positions = [data['pos'] for node, data in G.nodes(data=True)]
    pos_array = np.array(positions)
    Lambda_min = np.min(pos_array, axis=0)
    Lambda_max = np.max(pos_array, axis=0)

    if bounds is None:
        scales = Lambda_max - Lambda_min + 2 * padding
        shifts = Lambda_min - padding
        bounds = [shifts, shifts + scales]
    else:
        lower, upper = np.min(bounds, axis=0), np.max(bounds, axis=0)
        if not (np.all(Lambda_min >= lower) and np.all(Lambda_max <= upper)):
            raise ValueError("Lambda is not contained within the provided bounds.")
        scales = upper - lower
        shifts = lower

    voxel_dim = tuple(
        max(1, int(np.ceil(scales[i] / voxel_res)))
        for i in range(3)
    )

    Omega = UnitCubeMesh(*voxel_dim)
    Omega_coords = Omega.coordinates()
    Omega_coords[:] = Omega_coords * scales + shifts

    return Omega, bounds


=== tissue/geometry.py ===
import numpy as np
from dolfin import SubDomain, near, UserExpression, Point, DOLFIN_EPS

class BoundaryPoint(SubDomain):
    def __init__(self, coordinate, tolerance=DOLFIN_EPS, **kwargs):
        super().__init__(**kwargs)
        self.coordinate = coordinate
        self.tolerance = tolerance

    def inside(self, x, on_boundary: bool):
        return (on_boundary
            and near(x[0], self.coordinate[0], self.tolerance)
            and near(x[1], self.coordinate[1], self.tolerance)
            and near(x[2], self.coordinate[2], self.tolerance)
        )

class AxisPlane(SubDomain):
    def __init__(self, axis, coordinate, tolerance=DOLFIN_EPS, **kwargs):
        super().__init__(**kwargs)
        self.axis = axis
        self.coordinate = coordinate
        self.tolerance = tolerance

    def inside(self, x, on_boundary):
        return on_boundary and near(x[self.axis], self.coordinate, self.tolerance)

class CubeSubBoundary(SubDomain):
    def __init__(self, corner_1, corner_2):
        super().__init__()
        self.corner_1 = corner_1
        self.corner_2 = corner_2

    def inside(self, x, on_boundary):
        return (
            self.corner_1[0] <= x[0] <= self.corner_2[0] and
            self.corner_1[1] <= x[1] <= self.corner_2[1] and
            self.corner_1[2] <= x[2] <= self.corner_2[2]
        )


=== util.py ===
import numpy as np
from graphnics import *

BOX_EDGES = [(0, 1), (1, 2), (2, 3), (3, 0),
             (4, 5), (5, 6), (6, 7), (7, 4),
             (0, 4), (1, 5), (2, 6), (3, 7)]

def get_box_edges(corners):
    x_line, y_line, z_line = [], [], []
    for i, j in BOX_EDGES:
        x_line += [corners[i, 0], corners[j, 0], None]
        y_line += [corners[i, 1], corners[j, 1], None]
        z_line += [corners[i, 2], corners[j, 2], None]
    return np.array(x_line), np.array(y_line), np.array(z_line)

def compute_boundaries(coords):
    return (coords[:, 0].min(), coords[:, 0].max(),
            coords[:, 1].min(), coords[:, 1].max(),
            coords[:, 2].min(), coords[:, 2].max())


=== vtk.py ===
import meshio
import vtk
import numpy as np

def save_Lambda(save_path, Lambda, radius_map, uh1d=None):
    """
    Save a 1D network (Lambda) with per-point radius and optional 1D pressure.
    NOTE: If you plan to re-read with vtkUnstructuredGridReader, use a .vtk (legacy) extension.
    """
    points = Lambda.coordinates()
    cells = {"line": Lambda.cells()}

    radius_values = np.array([radius_map(point) for point in points])

    if uh1d is not None:
        uh1d_values = np.array([uh1d(point) for point in points])
        mesh = meshio.Mesh(points, cells, point_data={"radius": radius_values, "Pressure1D": uh1d_values})
    else:
        mesh = meshio.Mesh(points, cells, point_data={"radius": radius_values})

    mesh.write(save_path)

    reader = vtk.vtkUnstructuredGridReader()
    reader.SetFileName(save_path)
    reader.Update()
    geometry_filter = vtk.vtkGeometryFilter()
    geometry_filter.SetInputData(reader.GetOutput())
    geometry_filter.Update()
    polydata = geometry_filter.GetOutput()

    writer = vtk.vtkPolyDataWriter()
    writer.SetFileName(save_path)
    writer.SetInputData(polydata)
    writer.Write()

