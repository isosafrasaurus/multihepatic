Running "module reset". Resetting modules to system default. The following $MODULEPATH directories have been removed: None

# Alter the following to reflect the location of this file.
#
[ -n "$BASH_COMPLETION" ] || BASH_COMPLETION=/etc/bash_completion
[ -n "$BASH_COMPLETION_DIR" ] || BASH_COMPLETION_DIR=/etc/bash_completion.d
[ -n "$BASH_COMPLETION_COMPAT_DIR" ] || BASH_COMPLETION_COMPAT_DIR=/etc/bash_completion.d
readonly BASH_COMPLETION BASH_COMPLETION_DIR BASH_COMPLETION_COMPAT_DIR

# Set a couple of useful vars
#
UNAME=$( uname -s )
# strip OS type and version under Cygwin (e.g. CYGWIN_NT-5.1 => Cygwin)
UNAME=${UNAME/CYGWIN_*/Cygwin}

case ${UNAME} in
    Linux|GNU|GNU/*) USERLAND=GNU ;;
    *) USERLAND=${UNAME} ;;
esac

# Turn on extended globbing and programmable completion
shopt -s extglob progcomp

# A lot of the following one-liners were taken directly from the
# completion examples provided with the bash 2.04 source distribution

# Make directory commands see only directories
#complete -d pushd

# start of section containing compspecs that can be handled within bash

# user commands see only users
#complete -u su write chfn groups slay w sux runuser

# bg completes with stopped jobs
#complete -A stopped -P '"%' -S '"' bg

# other job commands
#complete -j -P '"%' -S '"' fg jobs disown

# readonly and unset complete with shell variables
#complete -v readonly unset

# set completes with set options
#complete -A setopt set

# shopt completes with shopt options
#complete -A shopt shopt

# helptopics
#complete -A helptopic help

# unalias completes with aliases
#complete -a unalias

# bind completes with readline bindings (make this more intelligent)
#complete -A binding bind

# type and which complete on commands
#complete -c command type which

# builtin completes on builtins
#complete -b builtin

# start of section containing completion functions called by other functions

# This function checks whether we have a given program on the system.
# No need for bulky functions in memory if we don't.
#
have()
{
    unset -v have
    # Completions for system administrator commands are installed as well in
    # case completion is attempted via `sudo command ...'.
    # In this packaged setup we don't need to do the availability test below
    # because only completions for commands that are actually available should
    # be in /etc/bash_completion.d anyway; not doing the test improves our load
    # time significantly.
    #PATH=$PATH:/sbin:/usr/sbin:/usr/local/sbin type $1 &>/dev/null &&
    have="yes"
}

# This function checks whether a given readline variable
# is `on'.
#
_rl_enabled()
{
    [[ "$( bind -v )" = *$1+([[:space:]])on* ]]
}

# This function shell-quotes the argument
quote()
{
    echo \'${1//\'/\'\\\'\'}\' #'# Help vim syntax highlighting
}

# @see _quote_readline_by_ref()
quote_readline()
{
    local quoted
    _quote_readline_by_ref "$1" ret
    printf %s "$ret"
} # quote_readline()


# This function shell-dequotes the argument
dequote()
{
    eval echo "$1" 2> /dev/null
}


# Assign variable one scope above the caller
# Usage: local "$1" && _upvar $1 "value(s)"
# Param: $1  Variable name to assign value to
# Param: $*  Value(s) to assign.  If multiple values, an array is
#            assigned, otherwise a single value is assigned.
# NOTE: For assigning multiple variables, use '_upvars'.  Do NOT
#       use multiple '_upvar' calls, since one '_upvar' call might
#       reassign a variable to be used by another '_upvar' call.
# See: http://fvue.nl/wiki/Bash:_Passing_variables_by_reference
_upvar() {
    if unset -v "$1"; then           # Unset & validate varname
        if (( $# == 2 )); then
            eval $1=\"\$2\"          # Return single value
        else
            eval $1=\(\"\${@:2}\"\)  # Return array
        fi
    fi
}


# Assign variables one scope above the caller
# Usage: local varname [varname ...] && 
#        _upvars [-v varname value] | [-aN varname [value ...]] ...
# Available OPTIONS:
#     -aN  Assign next N values to varname as array
#     -v   Assign single value to varname
# Return: 1 if error occurs
# See: http://fvue.nl/wiki/Bash:_Passing_variables_by_reference
_upvars() {
    if ! (( $# )); then
        echo "${FUNCNAME[0]}: usage: ${FUNCNAME[0]} [-v varname"\
            "value] | [-aN varname [value ...]] ..." 1>&2
        return 2
    fi
    while (( $# )); do
        case $1 in
            -a*)
                # Error checking
                [[ ${1#-a} ]] || { echo "bash: ${FUNCNAME[0]}: \`$1': missing"\
                    "number specifier" 1>&2; return 1; }
                printf %d "${1#-a}" &> /dev/null || { echo "bash:"\
                    "${FUNCNAME[0]}: \`$1': invalid number specifier" 1>&2
                    return 1; }
                # Assign array of -aN elements
                [[ "$2" ]] && unset -v "$2" && eval $2=\(\"\${@:3:${1#-a}}\"\) && 
                shift $((${1#-a} + 2)) || { echo "bash: ${FUNCNAME[0]}:"\
                    "\`$1${2+ }$2': missing argument(s)" 1>&2; return 1; }
                ;;
            -v)
                # Assign single value
                [[ "$2" ]] && unset -v "$2" && eval $2=\"\$3\" &&
                shift 3 || { echo "bash: ${FUNCNAME[0]}: $1: missing"\
                "argument(s)" 1>&2; return 1; }
                ;;
            *)
                echo "bash: ${FUNCNAME[0]}: $1: invalid option" 1>&2
                return 1 ;;
        esac
    done
}


# Reassemble command line words, excluding specified characters from the
# list of word completion separators (COMP_WORDBREAKS).
# @param $1 chars  Characters out of $COMP_WORDBREAKS which should
#     NOT be considered word breaks. This is useful for things like scp where
#     we want to return host:path and not only path, so we would pass the
#     colon (:) as $1 here.
# @param $2 words  Name of variable to return words to
# @param $3 cword  Name of variable to return cword to
#
__reassemble_comp_words_by_ref() {
    local exclude i j ref
    # Exclude word separator characters?
    if [[ $1 ]]; then
        # Yes, exclude word separator characters;
        # Exclude only those characters, which were really included
        exclude="${1//[^$COMP_WORDBREAKS]}"
    fi
        
    # Default to cword unchanged
    eval $3=$COMP_CWORD
    # Are characters excluded which were former included?
    if [[ $exclude ]]; then
        # Yes, list of word completion separators has shrunk;
        # Re-assemble words to complete
        for (( i=0, j=0; i < ${#COMP_WORDS[@]}; i++, j++)); do
            # Is current word not word 0 (the command itself) and is word not
            # empty and is word made up of just word separator characters to be
            # excluded?
            while [[ $i -gt 0 && ${COMP_WORDS[$i]} && 
                ${COMP_WORDS[$i]//[^$exclude]} == ${COMP_WORDS[$i]} 
            ]]; do
                [ $j -ge 2 ] && ((j--))
                # Append word separator to current word
                ref="$2[$j]"
                eval $2[$j]=\${!ref}\${COMP_WORDS[i]}
                # Indicate new cword
                [ $i = $COMP_CWORD ] && eval $3=$j
                # Indicate next word if available, else end *both* while and for loop
                (( $i < ${#COMP_WORDS[@]} - 1)) && ((i++)) || break 2
            done
            # Append word to current word
            ref="$2[$j]"
            eval $2[$j]=\${!ref}\${COMP_WORDS[i]}
            # Indicate new cword
            [[ $i == $COMP_CWORD ]] && eval $3=$j
        done
    else
        # No, list of word completions separators hasn't changed;
        eval $2=\( \"\${COMP_WORDS[@]}\" \)
    fi
} # __reassemble_comp_words_by_ref()


# @param $1 exclude  Characters out of $COMP_WORDBREAKS which should NOT be
#     considered word breaks. This is useful for things like scp where
#     we want to return host:path and not only path, so we would pass the
#     colon (:) as $1 in this case.  Bash-3 doesn't do word splitting, so this
#     ensures we get the same word on both bash-3 and bash-4.
# @param $2 words  Name of variable to return words to
# @param $3 cword  Name of variable to return cword to
# @param $4 cur  Name of variable to return current word to complete to
# @see ___get_cword_at_cursor_by_ref()
__get_cword_at_cursor_by_ref() {
    local cword words=()
    __reassemble_comp_words_by_ref "$1" words cword

    local i cur2
    local cur="$COMP_LINE"
    local index="$COMP_POINT"
    for (( i = 0; i <= cword; ++i )); do
        while [[
            # Current word fits in $cur?
            "${#cur}" -ge ${#words[i]} &&
            # $cur doesn't match cword?
            "${cur:0:${#words[i]}}" != "${words[i]}"
        ]]; do
            # Strip first character
            cur="${cur:1}"
            # Decrease cursor position
            ((index--))
        done

        # Does found word matches cword?
        if [[ "$i" -lt "$cword" ]]; then
            # No, cword lies further;
            local old_size="${#cur}"
            cur="${cur#${words[i]}}"
            local new_size="${#cur}"
            index=$(( index - old_size + new_size ))
        fi
    done

    if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
        # We messed up. At least return the whole word so things keep working
        cur2=${words[cword]}
    else
        cur2=${cur:0:$index}
    fi

    local "$2" "$3" "$4" && 
        _upvars -a${#words[@]} $2 "${words[@]}" -v $3 "$cword" -v $4 "$cur2"
}


# Get the word to complete and optional previous words.
# This is nicer than ${COMP_WORDS[$COMP_CWORD]}, since it handles cases
# where the user is completing in the middle of a word.
# (For example, if the line is "ls foobar",
# and the cursor is here -------->   ^
# Also one is able to cross over possible wordbreak characters.
# Usage: _get_comp_words_by_ref [OPTIONS] [VARNAMES]
# Available VARNAMES:
#     cur         Return cur via $cur
#     prev        Return prev via $prev
#     words       Return words via $words
#     cword       Return cword via $cword
#
# Available OPTIONS:
#     -n EXCLUDE  Characters out of $COMP_WORDBREAKS which should NOT be 
#                 considered word breaks. This is useful for things like scp
#                 where we want to return host:path and not only path, so we
#                 would pass the colon (:) as -n option in this case.  Bash-3
#                 doesn't do word splitting, so this ensures we get the same
#                 word on both bash-3 and bash-4.
#     -c VARNAME  Return cur via $VARNAME
#     -p VARNAME  Return prev via $VARNAME
#     -w VARNAME  Return words via $VARNAME
#     -i VARNAME  Return cword via $VARNAME
#
# Example usage:
#
#    $ _get_comp_words_by_ref -n : cur prev
#
_get_comp_words_by_ref()
{
    local exclude flag i OPTIND=1
    local cur cword words=()
    local upargs=() upvars=() vcur vcword vprev vwords

    while getopts "c:i:n:p:w:" flag "$@"; do
        case $flag in
            c) vcur=$OPTARG ;;
            i) vcword=$OPTARG ;;
            n) exclude=$OPTARG ;;
            p) vprev=$OPTARG ;;
            w) vwords=$OPTARG ;;
        esac
    done
    while [[ $# -ge $OPTIND ]]; do 
        case ${!OPTIND} in
            cur)   vcur=cur ;;
            prev)  vprev=prev ;;
            cword) vcword=cword ;;
            words) vwords=words ;;
            *) echo "bash: $FUNCNAME(): \`${!OPTIND}': unknown argument" \
                1>&2; return 1
        esac
        let "OPTIND += 1"
    done

    __get_cword_at_cursor_by_ref "$exclude" words cword cur

    [[ $vcur   ]] && { upvars+=("$vcur"  ); upargs+=(-v $vcur   "$cur"  ); }
    [[ $vcword ]] && { upvars+=("$vcword"); upargs+=(-v $vcword "$cword"); }
    [[ $vprev  ]] && { upvars+=("$vprev" ); upargs+=(-v $vprev 
        "${words[cword - 1]}"); }
    [[ $vwords ]] && { upvars+=("$vwords"); upargs+=(-a${#words[@]} $vwords
        "${words[@]}"); }

    (( ${#upvars[@]} )) && local "${upvars[@]}" && _upvars "${upargs[@]}"
}


# Get the word to complete.
# This is nicer than ${COMP_WORDS[$COMP_CWORD]}, since it handles cases
# where the user is completing in the middle of a word.
# (For example, if the line is "ls foobar",
# and the cursor is here -------->   ^
# @param $1 string  Characters out of $COMP_WORDBREAKS which should NOT be
#     considered word breaks. This is useful for things like scp where
#     we want to return host:path and not only path, so we would pass the
#     colon (:) as $1 in this case.  Bash-3 doesn't do word splitting, so this
#     ensures we get the same word on both bash-3 and bash-4.
# @param $2 integer  Index number of word to return, negatively offset to the
#     current word (default is 0, previous is 1), respecting the exclusions
#     given at $1.  For example, `_get_cword "=:" 1' returns the word left of
#     the current word, respecting the exclusions "=:".
# @deprecated  Use `_get_comp_words_by_ref cur' instead
# @see _get_comp_words_by_ref()
_get_cword()
{
    local LC_CTYPE=C
    local cword words
    __reassemble_comp_words_by_ref "$1" words cword

    # return previous word offset by $2
    if [[ ${2//[^0-9]/} ]]; then
        printf "%s" "${words[cword-$2]}"
    elif [[ "${#words[cword]}" -eq 0 || "$COMP_POINT" == "${#COMP_LINE}" ]]; then
        printf "%s" "${words[cword]}"
    else
        local i
        local cur="$COMP_LINE"
        local index="$COMP_POINT"
        for (( i = 0; i <= cword; ++i )); do
            while [[
                # Current word fits in $cur?
                "${#cur}" -ge ${#words[i]} &&
                # $cur doesn't match cword?
                "${cur:0:${#words[i]}}" != "${words[i]}"
            ]]; do
                # Strip first character
                cur="${cur:1}"
                # Decrease cursor position
                ((index--))
            done

            # Does found word matches cword?
            if [[ "$i" -lt "$cword" ]]; then
                # No, cword lies further;
                local old_size="${#cur}"
                cur="${cur#${words[i]}}"
                local new_size="${#cur}"
                index=$(( index - old_size + new_size ))
            fi
        done

        if [[ "${words[cword]:0:${#cur}}" != "$cur" ]]; then
            # We messed up! At least return the whole word so things
            # keep working
            printf "%s" "${words[cword]}"
        else
            printf "%s" "${cur:0:$index}"
        fi
    fi
} # _get_cword()


# Get word previous to the current word.
# This is a good alternative to `prev=${COMP_WORDS[COMP_CWORD-1]}' because bash4
# will properly return the previous word with respect to any given exclusions to
# COMP_WORDBREAKS.
# @deprecated  Use `_get_comp_words_by_ref cur prev' instead
# @see _get_comp_words_by_ref()
#
_get_pword() 
{
    if [ $COMP_CWORD -ge 1 ]; then
        _get_cword "${@:-}" 1;
    fi
}


# If the word-to-complete contains a colon (:), left-trim COMPREPLY items with
# word-to-complete.
# On bash-3, and bash-4 with a colon in COMP_WORDBREAKS, words containing
# colons are always completed as entire words if the word to complete contains
# a colon.  This function fixes this, by removing the colon-containing-prefix
# from COMPREPLY items.
# The preferred solution is to remove the colon (:) from COMP_WORDBREAKS in
# your .bashrc:
#
#    # Remove colon (:) from list of word completion separators
#    COMP_WORDBREAKS=${COMP_WORDBREAKS//:}
#
# See also: Bash FAQ - E13) Why does filename completion misbehave if a colon
# appears in the filename? - http://tiswww.case.edu/php/chet/bash/FAQ
# @param $1 current word to complete (cur)
# @modifies global array $COMPREPLY
#
__ltrim_colon_completions() {
    # If word-to-complete contains a colon,
    # and bash-version < 4,
    # or bash-version >= 4 and COMP_WORDBREAKS contains a colon
    if [[
        "$1" == *:* && (
            ${BASH_VERSINFO[0]} -lt 4 || 
            (${BASH_VERSINFO[0]} -ge 4 && "$COMP_WORDBREAKS" == *:*) 
        )
    ]]; then
        # Remove colon-word prefix from COMPREPLY items
        local colon_word=${1%${1##*:}}
        local i=${#COMPREPLY[*]}
        while [ $((--i)) -ge 0 ]; do
            COMPREPLY[$i]=${COMPREPLY[$i]#"$colon_word"}
        done
    fi
} # __ltrim_colon_completions()


# This function quotes the argument in a way so that readline dequoting
# results in the original argument.  This is necessary for at least
# `compgen' which requires its arguments quoted/escaped:
#
#     $ ls "a'b/"
#     c
#     $ compgen -f "a'b/"       # Wrong, doesn't return output
#     $ compgen -f "a\'b/"      # Good (bash-4)
#     a\'b/c
#     $ compgen -f "a\\\\\'b/"  # Good (bash-3)
#     a\'b/c
#
# On bash-3, special characters need to be escaped extra.  This is
# unless the first character is a single quote (').  If the single
# quote appears further down the string, bash default completion also
# fails, e.g.:
#
#     $ ls 'a&b/'
#     f
#     $ foo 'a&b/<TAB>  # Becomes: foo 'a&b/f'
#     $ foo a'&b/<TAB>  # Nothing happens
#
# See also:
# - http://lists.gnu.org/archive/html/bug-bash/2009-03/msg00155.html
# - http://www.mail-archive.com/bash-completion-devel@lists.alioth.\
#   debian.org/msg01944.html
# @param $1  Argument to quote
# @param $2  Name of variable to return result to
_quote_readline_by_ref()
{
    if [[ ${1:0:1} == "'" ]]; then
        if [[ ${BASH_VERSINFO[0]} -ge 4 ]]; then
            # Leave out first character
            printf -v $2 %s "${1:1}"
        else
            # Quote word, leaving out first character
            printf -v $2 %q "${1:1}"
            # Double-quote word (bash-3)
            printf -v $2 %q ${!2}
        fi
    elif [[ ${BASH_VERSINFO[0]} -le 3 && ${1:0:1} == '"' ]]; then
        printf -v $2 %q "${1:1}"
    else
        printf -v $2 %q "$1"
    fi

    # If result becomes quoted like this: $'string', re-evaluate in order to
    # drop the additional quoting.  See also: http://www.mail-archive.com/
    # bash-completion-devel@lists.alioth.debian.org/msg01942.html
    [[ ${!2:0:1} == '$' ]] && eval $2=${!2}
} # _quote_readline_by_ref()


# This function turns on "-o filenames" behavior dynamically. It is present
# for bash < 4 reasons. See http://bugs.debian.org/272660#64 for info about
# the bash < 4 compgen hack.
_compopt_o_filenames()
{
    # We test for compopt availability first because directly invoking it on
    # bash < 4 at this point may cause terminal echo to be turned off for some
    # reason, see https://bugzilla.redhat.com/653669 for more info.
    type compopt &>/dev/null && compopt -o filenames 2>/dev/null || \
        compgen -f /non-existing-dir/ >/dev/null
}


# This function performs file and directory completion. It's better than
# simply using 'compgen -f', because it honours spaces in filenames.
# @param $1  If `-d', complete only on directories.  Otherwise filter/pick only
#            completions with `.$1' and the uppercase version of it as file
#            extension.
#
_filedir()
{
    local i IFS=$'\n' xspec

    _tilde "$cur" || return 0

    local -a toks
    local quoted tmp

    _quote_readline_by_ref "$cur" quoted
    toks=( ${toks[@]-} $(
        compgen -d -- "$quoted" | {
            while read -r tmp; do
                # TODO: I have removed a "[ -n $tmp ] &&" before 'printf ..',
                #       and everything works again. If this bug suddenly
                #       appears again (i.e. "cd /b<TAB>" becomes "cd /"),
                #       remember to check for other similar conditionals (here
                #       and _filedir_xspec()). --David
                printf '%s\n' $tmp
            done
        }
    ))

    if [[ "$1" != -d ]]; then
        # Munge xspec to contain uppercase version too
        [[ ${BASH_VERSINFO[0]} -ge 4 ]] && \
            xspec=${1:+"!*.@($1|${1^^})"} || \
            xspec=${1:+"!*.@($1|$(printf %s $1 | tr '[:lower:]' '[:upper:]'))"}
        toks=( ${toks[@]-} $( compgen -f -X "$xspec" -- $quoted) )
    fi
    [ ${#toks[@]} -ne 0 ] && _compopt_o_filenames

    COMPREPLY=( "${COMPREPLY[@]}" "${toks[@]}" )
} # _filedir()


# This function splits $cur=--foo=bar into $prev=--foo, $cur=bar, making it
# easier to support both "--foo bar" and "--foo=bar" style completions.
# Returns 0 if current option was split, 1 otherwise.
#
_split_longopt()
{
    if [[ "$cur" == --?*=* ]]; then
        # Cut also backslash before '=' in case it ended up there
        # for some reason.
        prev="${cur%%?(\\)=*}"
        cur="${cur#*=}"
        return 0
    fi

    return 1
}

# This function tries to parse the help output of the given command.
# @param $1  command
# @param $2  command options (default: --help)
#
_parse_help() {
    $1 ${2:---help} 2>&1 | sed -e '/^[[:space:]]*-/!d' -e 's|[,/]| |g' | \
        awk '{ print $1; if ($2 ~ /^-/) { print $2 } }' | sed -e 's|[<=].*||'
}

# This function completes on signal names
#
_signals()
{
    local i

    # standard signal completion is rather braindead, so we need
    # to hack around to get what we want here, which is to
    # complete on a dash, followed by the signal name minus
    # the SIG prefix
    COMPREPLY=( $( compgen -A signal SIG${cur#-} ))
    for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
        COMPREPLY[i]=-${COMPREPLY[i]#SIG}
    done
}

# This function completes on known mac addresses
#
_mac_addresses()
{
    local re='\([A-Fa-f0-9]\{2\}:\)\{5\}[A-Fa-f0-9]\{2\}'
    local PATH="$PATH:/sbin:/usr/sbin"

    # Local interfaces (Linux only?)
    COMPREPLY=( "${COMPREPLY[@]}" $( ifconfig -a 2>/dev/null | sed -ne \
        "s/.*[[:space:]]HWaddr[[:space:]]\{1,\}\($re\)[[:space:]]*$/\1/p" ) )

    # ARP cache
    COMPREPLY=( "${COMPREPLY[@]}" $( arp -an 2>/dev/null | sed -ne \
        "s/.*[[:space:]]\($re\)[[:space:]].*/\1/p" -ne \
        "s/.*[[:space:]]\($re\)[[:space:]]*$/\1/p" ) )

    # /etc/ethers
    COMPREPLY=( "${COMPREPLY[@]}" $( sed -ne \
        "s/^[[:space:]]*\($re\)[[:space:]].*/\1/p" /etc/ethers 2>/dev/null ) )

    COMPREPLY=( $( compgen -W '${COMPREPLY[@]}' -- "$cur" ) )
    __ltrim_colon_completions "$cur"
}

# This function completes on configured network interfaces
#
_configured_interfaces()
{
    if [ -f /etc/debian_version ]; then
        # Debian system
        COMPREPLY=( $( compgen -W "$( sed -ne 's|^iface \([^ ]\{1,\}\).*$|\1|p'\
            /etc/network/interfaces )" -- "$cur" ) )
    elif [ -f /etc/SuSE-release ]; then
        # SuSE system
        COMPREPLY=( $( compgen -W "$( printf '%s\n' \
            /etc/sysconfig/network/ifcfg-* | \
            sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ) )
    elif [ -f /etc/pld-release ]; then
        # PLD Linux
        COMPREPLY=( $( compgen -W "$( command ls -B \
            /etc/sysconfig/interfaces | \
            sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ) )
    else
        # Assume Red Hat
        COMPREPLY=( $( compgen -W "$( printf '%s\n' \
            /etc/sysconfig/network-scripts/ifcfg-* | \
            sed -ne 's|.*ifcfg-\(.*\)|\1|p' )" -- "$cur" ) )
    fi
}

# This function completes on available kernels
#
_kernel_versions()
{
    COMPREPLY=( $( compgen -W '$( command ls /lib/modules )' -- "$cur" ) )
}

# This function completes on all available network interfaces
# -a: restrict to active interfaces only
# -w: restrict to wireless interfaces only
#
_available_interfaces()
{
    local cmd

    if [ "${1:-}" = -w ]; then
        cmd="iwconfig"
    elif [ "${1:-}" = -a ]; then
        cmd="ifconfig"
    else
        cmd="ifconfig -a"
    fi

    COMPREPLY=( $( eval PATH="$PATH:/sbin" $cmd 2>/dev/null | \
        awk '/^[^ \t]/ { print $1 }' ) )
    COMPREPLY=( $( compgen -W '${COMPREPLY[@]/%[[:punct:]]/}' -- "$cur" ) )
}


# Perform tilde (~) completion
# @return  True (0) if completion needs further processing, 
#          False (> 0) if tilde is followed by a valid username, completions
#          are put in COMPREPLY and no further processing is necessary.
_tilde() {
    local result=0
    # Does $1 start with tilde (~) and doesn't contain slash (/)?
    if [[ ${1:0:1} == "~" && $1 == ${1//\/} ]]; then
        _compopt_o_filenames
        # Try generate username completions
        COMPREPLY=( $( compgen -P '~' -u "${1#\~}" ) )
        result=${#COMPREPLY[@]}
    fi
    return $result
}


# Expand variable starting with tilde (~)
# We want to expand ~foo/... to /home/foo/... to avoid problems when
# word-to-complete starting with a tilde is fed to commands and ending up
# quoted instead of expanded.
# Only the first portion of the variable from the tilde up to the first slash
# (~../) is expanded.  The remainder of the variable, containing for example
# a dollar sign variable ($) or asterisk (*) is not expanded.
# Example usage:
#
#    $ v="~"; __expand_tilde_by_ref v; echo "$v"
#
# Example output:
#
#       v                  output
#    --------         ----------------
#    ~                /home/user
#    ~foo/bar         /home/foo/bar
#    ~foo/$HOME       /home/foo/$HOME
#    ~foo/a  b        /home/foo/a  b
#    ~foo/*           /home/foo/*
#  
# @param $1  Name of variable (not the value of the variable) to expand
__expand_tilde_by_ref() {
    # Does $1 start with tilde (~)?
    if [ "${!1:0:1}" = "~" ]; then
        # Does $1 contain slash (/)?
        if [ "${!1}" != "${!1//\/}" ]; then
            # Yes, $1 contains slash;
            # 1: Remove * including and after first slash (/), i.e. "~a/b"
            #    becomes "~a".  Double quotes allow eval.
            # 2: Remove * before the first slash (/), i.e. "~a/b"
            #    becomes "b".  Single quotes prevent eval.
            #       +-----1----+ +---2----+
            eval $1="${!1/%\/*}"/'${!1#*/}'
        else 
            # No, $1 doesn't contain slash
            eval $1="${!1}"
        fi
    fi
} # __expand_tilde_by_ref()


# This function expands tildes in pathnames
#
_expand()
{
    # FIXME: Why was this here?
    #[ "$cur" != "${cur%\\}" ] && cur="$cur\\"

    # Expand ~username type directory specifications.  We want to expand
    # ~foo/... to /home/foo/... to avoid problems when $cur starting with
    # a tilde is fed to commands and ending up quoted instead of expanded.

    if [[ "$cur" == \~*/* ]]; then
        eval cur=$cur
    elif [[ "$cur" == \~* ]]; then
        cur=${cur#\~}
        COMPREPLY=( $( compgen -P '~' -u "$cur" ) )
        [ ${#COMPREPLY[@]} -eq 1 ] && eval COMPREPLY[0]=${COMPREPLY[0]}
        return ${#COMPREPLY[@]}
    fi
}

# This function completes on process IDs.
# AIX and Solaris ps prefers X/Open syntax.
[[ $UNAME == SunOS || $UNAME == AIX ]] &&
_pids()
{
    COMPREPLY=( $( compgen -W '$( command ps -efo pid | sed 1d )' -- "$cur" ))
} ||
_pids()
{
    COMPREPLY=( $( compgen -W '$( command ps axo pid= )' -- "$cur" ) )
}

# This function completes on process group IDs.
# AIX and SunOS prefer X/Open, all else should be BSD.
[[ $UNAME == SunOS || $UNAME == AIX ]] &&
_pgids()
{
    COMPREPLY=( $( compgen -W '$( command ps -efo pgid | sed 1d )' -- "$cur" ))
} ||
_pgids()
{
    COMPREPLY=( $( compgen -W '$( command ps axo pgid= )' -- "$cur" ))
}

# This function completes on process names.
# AIX and SunOS prefer X/Open, all else should be BSD.
[[ $UNAME == SunOS || $UNAME == AIX ]] &&
_pnames()
{
    COMPREPLY=( $( compgen -X '<defunct>' -W '$( command ps -efo comm | \
        sed -e 1d -e "s:.*/::" -e "s/^-//" | sort -u )' -- "$cur" ) )
} ||
_pnames()
{
    # FIXME: completes "[kblockd/0]" to "0". Previously it was completed
    # to "kblockd" which isn't correct either. "kblockd/0" would be
    # arguably most correct, but killall from psmisc 22 treats arguments
    # containing "/" specially unless -r is given so that wouldn't quite
    # work either. Perhaps it'd be best to not complete these to anything
    # for now.
    # Not using "ps axo comm" because under some Linux kernels, it
    # truncates command names (see e.g. http://bugs.debian.org/497540#19)
    COMPREPLY=( $( compgen -X '<defunct>' -W '$( command ps axo command= | \
        sed -e "s/ .*//" -e "s:.*/::" -e "s/:$//" -e "s/^[[(-]//" \
            -e "s/[])]$//" | sort -u )' -- "$cur" ) )
}

# This function completes on user IDs
#
_uids()
{
    if type getent &>/dev/null; then
        COMPREPLY=( $( compgen -W '$( getent passwd | cut -d: -f3 )' -- "$cur" ) )
    elif type perl &>/dev/null; then
        COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($uid) = (getpwent)[2]) { print $uid . "\n" }'"'"' )' -- "$cur" ) )
    else
        # make do with /etc/passwd
        COMPREPLY=( $( compgen -W '$( cut -d: -f3 /etc/passwd )' -- "$cur" ) )
    fi
}

# This function completes on group IDs
#
_gids()
{
    if type getent &>/dev/null; then
        COMPREPLY=( $( compgen -W '$( getent group | cut -d: -f3 )' \
            -- "$cur" ) )
    elif type perl &>/dev/null; then
        COMPREPLY=( $( compgen -W '$( perl -e '"'"'while (($gid) = (getgrent)[2]) { print $gid . "\n" }'"'"' )' -- "$cur" ) )
    else
        # make do with /etc/group
        COMPREPLY=( $( compgen -W '$( cut -d: -f3 /etc/group )' -- "$cur" ) )
    fi
}

# This function completes on services
#
_services()
{
    local sysvdir famdir
    [ -d /etc/rc.d/init.d ] && sysvdir=/etc/rc.d/init.d || sysvdir=/etc/init.d
    famdir=/etc/xinetd.d
    COMPREPLY=( $( printf '%s\n' \
        $sysvdir/!(*.rpm@(orig|new|save)|*~|functions) ) )

    if [ -d $famdir ]; then
        COMPREPLY=( "${COMPREPLY[@]}" $( printf '%s\n' \
            $famdir/!(*.rpm@(orig|new|save)|*~) ) )
    fi

    COMPREPLY=( $( compgen -W '${COMPREPLY[@]#@($sysvdir|$famdir)/}' -- "$cur" ) )
}

# This function completes on modules
#
_modules()
{
    local modpath
    modpath=/lib/modules/$1
    COMPREPLY=( $( compgen -W "$( command ls -R $modpath | \
        sed -ne 's/^\(.*\)\.k\{0,1\}o\(\.gz\)\{0,1\}$/\1/p' )" -- "$cur" ) )
}

# This function completes on installed modules
#
_installed_modules()
{
    COMPREPLY=( $( compgen -W "$( PATH="$PATH:/sbin" lsmod | \
        awk '{if (NR != 1) print $1}' )" -- "$1" ) )
}

# This function completes on user or user:group format; as for chown and cpio.
#
# The : must be added manually; it will only complete usernames initially.
# The legacy user.group format is not supported.
#
# @param $1  If -u, only return users/groups the user has access to in
#            context of current completion.
_usergroup()
{
    if [[ $cur = *\\\\* || $cur = *:*:* ]]; then
        # Give up early on if something seems horribly wrong.
        return
    elif [[ $cur = *\\:* ]]; then
        # Completing group after 'user\:gr<TAB>'.
        # Reply with a list of groups prefixed with 'user:', readline will
        # escape to the colon.
        local prefix
        prefix=${cur%%*([^:])}
        prefix=${prefix//\\}
        local mycur="${cur#*[:]}"
        if [[ $1 == -u ]]; then
            _allowed_groups "$mycur"
        else
            local IFS=$'\n'
            COMPREPLY=( $( compgen -g -- "$mycur" ) )
        fi
        COMPREPLY=( $( compgen -P "$prefix" -W "${COMPREPLY[@]}" ) )
    elif [[ $cur = *:* ]]; then
        # Completing group after 'user:gr<TAB>'.
        # Reply with a list of unprefixed groups since readline with split on :
        # and only replace the 'gr' part
        local mycur="${cur#*:}"
        if [[ $1 == -u ]]; then
            _allowed_groups "$mycur"
        else
            local IFS=$'\n'
            COMPREPLY=( $( compgen -g -- "$mycur" ) )
        fi
    else
        # Completing a partial 'usernam<TAB>'.
        #
        # Don't suffix with a : because readline will escape it and add a
        # slash. It's better to complete into 'chown username ' than 'chown
        # username\:'.
        if [[ $1 == -u ]]; then
            _allowed_users "$cur"
        else
            local IFS=$'\n'
            COMPREPLY=( $( compgen -u -- "$cur" ) )
        fi
    fi
}

_allowed_users()
{
    if _complete_as_root; then
        local IFS=$'\n'
        COMPREPLY=( $( compgen -u -- "${1:-$cur}" ) )
    else
        local IFS=$'\n '
        COMPREPLY=( $( compgen -W \
            "$( id -un 2>/dev/null || whoami 2>/dev/null )" -- "${1:-$cur}" ) )
    fi
}

_allowed_groups()
{
    if _complete_as_root; then
        local IFS=$'\n'
        COMPREPLY=( $( compgen -g -- "$1" ) )
    else
        local IFS=$'\n '
        COMPREPLY=( $( compgen -W \
            "$( id -Gn 2>/dev/null || groups 2>/dev/null )" -- "$1" ) )
    fi
}

# This function completes on valid shells
#
_shells()
{
    COMPREPLY=( "${COMPREPLY[@]}" $( compgen -W \
        '$( command grep "^[[:space:]]*/" /etc/shells 2>/dev/null )' \
        -- "$cur" ) )
}

# This function completes on valid filesystem types
#
_fstypes()
{
    local fss

    if [ -e /proc/filesystems ] ; then
        # Linux
        fss="$( cut -d$'\t' -f2 /proc/filesystems )
             $( awk '! /\*/ { print $NF }' /etc/filesystems 2>/dev/null )"
    else
        # Generic
        fss="$( awk '/^[ \t]*[^#]/ { print $3 }' /etc/fstab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $3 }' /etc/mnttab 2>/dev/null )
             $( awk '/^[ \t]*[^#]/ { print $4 }' /etc/vfstab 2>/dev/null )
             $( awk '{ print $1 }' /etc/dfs/fstypes 2>/dev/null )
             $( [ -d /etc/fs ] && command ls /etc/fs )"
    fi

    [ -n "$fss" ] && \
        COMPREPLY=( "${COMPREPLY[@]}" $( compgen -W "$fss" -- "$cur" ) )
}

# Get real command.
# - arg: $1  Command
# - stdout:  Filename of command in PATH with possible symbolic links resolved.
#            Empty string if command not found.
# - return:  True (0) if command found, False (> 0) if not.
_realcommand()
{
    type -P "$1" > /dev/null && {
        if type -p realpath > /dev/null; then
            realpath "$(type -P "$1")"
        elif type -p readlink > /dev/null; then
            readlink -f "$(type -P "$1")"
        else
            type -P "$1"
        fi
    }
}

# This function returns the first arugment, excluding options
# @param $1 chars  Characters out of $COMP_WORDBREAKS which should
#     NOT be considered word breaks. See __reassemble_comp_words_by_ref.
_get_first_arg()
{
    local i

    arg=
    for (( i=1; i < COMP_CWORD; i++ )); do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            arg=${COMP_WORDS[i]}
            break
        fi
    done
}


# This function counts the number of args, excluding options
# @param $1 chars  Characters out of $COMP_WORDBREAKS which should
#     NOT be considered word breaks. See __reassemble_comp_words_by_ref.
_count_args()
{
    local i cword words
    __reassemble_comp_words_by_ref "$1" words cword

    args=1
    for i in "${words[@]:1:cword-1}"; do
        [[ "$i" != -* ]] && args=$(($args+1))
    done
}

# This function completes on PCI IDs
#
_pci_ids()
{
    COMPREPLY=( ${COMPREPLY[@]:-} $( compgen -W \
        "$( PATH="$PATH:/sbin" lspci -n | awk '{print $3}')" -- "$cur" ) )
}

# This function completes on USB IDs
#
_usb_ids()
{
    COMPREPLY=( ${COMPREPLY[@]:-} $( compgen -W \
        "$( PATH="$PATH:/sbin" lsusb | awk '{print $6}' )" -- "$cur" ) )
}

# CD device names
_cd_devices()
{
    COMPREPLY=( "${COMPREPLY[@]}"
        $( compgen -f -d -X "!*/?([amrs])cd*" -- "${cur:-/dev/}" ) )
}

# DVD device names
_dvd_devices()
{
    COMPREPLY=( "${COMPREPLY[@]}"
        $( compgen -f -d -X "!*/?(r)dvd*" -- "${cur:-/dev/}" ) )
}

# start of section containing completion functions for external programs

# a little help for FreeBSD ports users
[ $UNAME = FreeBSD ] && complete -W 'index search fetch fetch-list extract \
    patch configure build install reinstall deinstall clean clean-depends \
    kernel buildworld' make

# This function provides simple user@host completion
#
_user_at_host() {
    local cur

    COMPREPLY=()
    _get_comp_words_by_ref -n : cur

    if [[ $cur == *@* ]]; then
        _known_hosts_real "$cur"
    else
        COMPREPLY=( $( compgen -u -- "$cur" ) )
    fi

    return 0
}
shopt -u hostcomplete && complete -F _user_at_host -o nospace talk ytalk finger

# NOTE: Using this function as a helper function is deprecated.  Use
#       `_known_hosts_real' instead.
_known_hosts()
{
    local options
    COMPREPLY=()

    # NOTE: Using `_known_hosts' as a helper function and passing options
    #       to `_known_hosts' is deprecated: Use `_known_hosts_real' instead.
    [[ "$1" == -a || "$2" == -a ]] && options=-a
    [[ "$1" == -c || "$2" == -c ]] && options="$options -c"
    _known_hosts_real $options "$(_get_cword :)"
} # _known_hosts()

# Helper function for completing _known_hosts.
# This function performs host completion based on ssh's config and known_hosts
# files, as well as hostnames reported by avahi-browse if
# COMP_KNOWN_HOSTS_WITH_AVAHI is set to a non-empty value.  Also hosts from
# HOSTFILE (compgen -A hostname) are added, unless
# COMP_KNOWN_HOSTS_WITH_HOSTFILE is set to an empty value.
# Usage: _known_hosts_real [OPTIONS] CWORD
# Options:  -a             Use aliases
#           -c             Use `:' suffix
#           -F configfile  Use `configfile' for configuration settings
#           -p PREFIX      Use PREFIX
# Return: Completions, starting with CWORD, are added to COMPREPLY[]
_known_hosts_real()
{
    local configfile flag prefix
    local cur curd awkcur user suffix aliases i host
    local -a kh khd config

    local OPTIND=1
    while getopts "acF:p:" flag "$@"; do
        case $flag in
            a) aliases='yes' ;;
            c) suffix=':' ;;
            F) configfile=$OPTARG ;;
            p) prefix=$OPTARG ;;
        esac
    done
    [ $# -lt $OPTIND ] && echo "error: $FUNCNAME: missing mandatory argument CWORD"
    cur=${!OPTIND}; let "OPTIND += 1"
    [ $# -ge $OPTIND ] && echo "error: $FUNCNAME("$@"): unprocessed arguments:"\
    $(while [ $# -ge $OPTIND ]; do printf '%s\n' ${!OPTIND}; shift; done)

    [[ $cur == *@* ]] && user=${cur%@*}@ && cur=${cur#*@}
    kh=()

    # ssh config files
    if [ -n "$configfile" ]; then
        [ -r "$configfile" ] &&
        config=( "${config[@]}" "$configfile" )
    else
        for i in /etc/ssh/ssh_config "${HOME}/.ssh/config" \
            "${HOME}/.ssh2/config"; do
            [ -r $i ] && config=( "${config[@]}" "$i" )
        done
    fi

    # Known hosts files from configs
    if [ ${#config[@]} -gt 0 ]; then
        local OIFS=$IFS IFS=$'\n'
        local -a tmpkh
        # expand paths (if present) to global and user known hosts files
        # TODO(?): try to make known hosts files with more than one consecutive
        #          spaces in their name work (watch out for ~ expansion
        #          breakage! Alioth#311595)
        tmpkh=( $( awk 'sub("^[ \t]*([Gg][Ll][Oo][Bb][Aa][Ll]|[Uu][Ss][Ee][Rr])[Kk][Nn][Oo][Ww][Nn][Hh][Oo][Ss][Tt][Ss][Ff][Ii][Ll][Ee][ \t]+", "") { print $0 }' "${config[@]}" | sort -u ) )
        for i in "${tmpkh[@]}"; do
            # Remove possible quotes
            i=${i//\"}
            # Eval/expand possible `~' or `~user'
            __expand_tilde_by_ref i
            [ -r "$i" ] && kh=( "${kh[@]}" "$i" )
        done
        IFS=$OIFS
    fi

    if [ -z "$configfile" ]; then
        # Global and user known_hosts files
        for i in /etc/ssh/ssh_known_hosts /etc/ssh/ssh_known_hosts2 \
            /etc/known_hosts /etc/known_hosts2 ~/.ssh/known_hosts \
            ~/.ssh/known_hosts2; do
            [ -r $i ] && kh=( "${kh[@]}" $i )
        done
        for i in /etc/ssh2/knownhosts ~/.ssh2/hostkeys; do
            [ -d $i ] && khd=( "${khd[@]}" $i/*pub )
        done
    fi

    # If we have known_hosts files to use
    if [[ ${#kh[@]} -gt 0 || ${#khd[@]} -gt 0 ]]; then
        # Escape slashes and dots in paths for awk
        awkcur=${cur//\//\\\/}
        awkcur=${awkcur//\./\\\.}
        curd=$awkcur

        if [[ "$awkcur" == [0-9]*[.:]* ]]; then
            # Digits followed by a dot or a colon - just search for that
            awkcur="^$awkcur[.:]*"
        elif [[ "$awkcur" == [0-9]* ]]; then
            # Digits followed by no dot or colon - search for digits followed
            # by a dot or a colon
            awkcur="^$awkcur.*[.:]"
        elif [ -z "$awkcur" ]; then
            # A blank - search for a dot, a colon, or an alpha character
            awkcur="[a-z.:]"
        else
            awkcur="^$awkcur"
        fi

        if [ ${#kh[@]} -gt 0 ]; then
            # FS needs to look for a comma separated list
            COMPREPLY=( "${COMPREPLY[@]}" $( awk 'BEGIN {FS=","}
            /^\s*[^|\#]/ {for (i=1; i<=2; ++i) { \
            sub(" .*$", "", $i); \
            sub("^\\[", "", $i); sub("\\](:[0-9]+)?$", "", $i); \
            if ($i ~ /'"$awkcur"'/) {print $i} \
            }}' "${kh[@]}" 2>/dev/null ) )
        fi
        if [ ${#khd[@]} -gt 0 ]; then
            # Needs to look for files called
            # .../.ssh2/key_22_<hostname>.pub
            # dont fork any processes, because in a cluster environment,
            # there can be hundreds of hostkeys
            for i in "${khd[@]}" ; do
                if [[ "$i" == *key_22_$curd*.pub && -r "$i" ]]; then
                    host=${i/#*key_22_/}
                    host=${host/%.pub/}
                    COMPREPLY=( "${COMPREPLY[@]}" $host )
                fi
            done
        fi

        # apply suffix and prefix
        for (( i=0; i < ${#COMPREPLY[@]}; i++ )); do
            COMPREPLY[i]=$prefix$user${COMPREPLY[i]}$suffix
        done
    fi

    # append any available aliases from config files
    if [[ ${#config[@]} -gt 0 && -n "$aliases" ]]; then
        local hosts=$( sed -ne 's/^[ \t]*[Hh][Oo][Ss][Tt]\([Nn][Aa][Mm][Ee]\)\{0,1\}['"$'\t '"']\{1,\}\([^#*?]*\)\(#.*\)\{0,1\}$/\2/p' "${config[@]}" )
        COMPREPLY=( "${COMPREPLY[@]}" $( compgen  -P "$prefix$user" \
            -S "$suffix" -W "$hosts" -- "$cur" ) )
    fi

    # Add hosts reported by avahi-browse, if desired and it's available.
    if [[ ${COMP_KNOWN_HOSTS_WITH_AVAHI:-} ]] && \
        type avahi-browse &>/dev/null; then
        # The original call to avahi-browse also had "-k", to avoid lookups
        # into avahi's services DB. We don't need the name of the service, and
        # if it contains ";", it may mistify the result. But on Gentoo (at
        # least), -k wasn't available (even if mentioned in the manpage) some
        # time ago, so...
        COMPREPLY=( "${COMPREPLY[@]}" $( \
            compgen -P "$prefix$user" -S "$suffix" -W \
            "$( avahi-browse -cpr _workstation._tcp 2>/dev/null | \
                 awk -F';' '/^=/ { print $7 }' | sort -u )" -- "$cur" ) )
    fi

    # Add results of normal hostname completion, unless
    # `COMP_KNOWN_HOSTS_WITH_HOSTFILE' is set to an empty value.
    if [ -n "${COMP_KNOWN_HOSTS_WITH_HOSTFILE-1}" ]; then
        COMPREPLY=( "${COMPREPLY[@]}"
            $( compgen -A hostname -P "$prefix$user" -S "$suffix" -- "$cur" ) )
    fi

    __ltrim_colon_completions "$prefix$user$cur"

    return 0
} # _known_hosts_real()
#complete -F _known_hosts traceroute traceroute6 tracepath tracepath6 ping \
#    ping6 fping fping6 telnet host nslookup rsh rlogin ftp dig mtr \
#    ssh-installkeys showmount

# This meta-cd function observes the CDPATH variable, so that cd additionally
# completes on directories under those specified in CDPATH.
#
_cd()
{
    local cur IFS=$'\n' i j k
    _get_comp_words_by_ref cur

    # try to allow variable completion
    if [[ "$cur" == ?(\\)\$* ]]; then
        COMPREPLY=( $( compgen -v -P '$' -- "${cur#?(\\)$}" ) )
        return 0
    fi

    _compopt_o_filenames

    # Use standard dir completion if no CDPATH or parameter starts with /,
    # ./ or ../
    if [[ -z "${CDPATH:-}" || "$cur" == ?(.)?(.)/* ]]; then
        _filedir -d
        return 0
    fi

    local -r mark_dirs=$(_rl_enabled mark-directories && echo y)
    local -r mark_symdirs=$(_rl_enabled mark-symlinked-directories && echo y)

    # we have a CDPATH, so loop on its contents
    for i in ${CDPATH//:/$'\n'}; do
        # create an array of matched subdirs
        k="${#COMPREPLY[@]}"
        for j in $( compgen -d $i/$cur ); do
            if [[ ( $mark_symdirs && -h $j || $mark_dirs && ! -h $j ) && ! -d ${j#$i/} ]]; then
                j="${j}/"
            fi
            COMPREPLY[k++]=${j#$i/}
        done
    done

    _filedir -d

    if [[ ${#COMPREPLY[@]} -eq 1 ]]; then
        i=${COMPREPLY[0]}
        if [[ "$i" == "$cur" && $i != "*/" ]]; then
            COMPREPLY[0]="${i}/"
        fi
    fi

    return 0
}
if shopt -q cdable_vars; then
    complete -v -F _cd -o nospace cd
else
    complete -F _cd -o nospace cd
fi

# a wrapper method for the next one, when the offset is unknown
_command()
{
    local offset i

    # find actual offset, as position of the first non-option
    offset=1
    for (( i=1; i <= COMP_CWORD; i++ )); do
        if [[ "${COMP_WORDS[i]}" != -* ]]; then
            offset=$i
            break
        fi
    done
    _command_offset $offset
}

# A meta-command completion function for commands like sudo(8), which need to
# first complete on a command, then complete according to that command's own
# completion definition - currently not quite foolproof (e.g. mount and umount
# don't work properly), but still quite useful.
#
_command_offset()
{
    local cur func cline cspec noglob cmd i char_offset word_offset \
        _COMMAND_FUNC _COMMAND_FUNC_ARGS

    word_offset=$1

    # rewrite current completion context before invoking
    # actual command completion

    # find new first word position, then
    # rewrite COMP_LINE and adjust COMP_POINT
    local first_word=${COMP_WORDS[$word_offset]}
    for (( i=0; i <= ${#COMP_LINE}; i++ )); do
        if [[ "${COMP_LINE:$i:${#first_word}}" == "$first_word" ]]; then
            char_offset=$i
            break
        fi
    done
    COMP_LINE=${COMP_LINE:$char_offset}
    COMP_POINT=$(( COMP_POINT - $char_offset ))

    # shift COMP_WORDS elements and adjust COMP_CWORD
    for (( i=0; i <= COMP_CWORD - $word_offset; i++ )); do
        COMP_WORDS[i]=${COMP_WORDS[i+$word_offset]}
    done
    for (( i; i <= COMP_CWORD; i++ )); do
        unset COMP_WORDS[i];
    done
    COMP_CWORD=$(( $COMP_CWORD - $word_offset ))

    COMPREPLY=()
    _get_comp_words_by_ref cur

    if [[ $COMP_CWORD -eq 0 ]]; then
        _compopt_o_filenames
        COMPREPLY=( $( compgen -c -- "$cur" ) )
    else
        cmd=${COMP_WORDS[0]}
        if complete -p ${cmd##*/} &>/dev/null; then
            cspec=$( complete -p ${cmd##*/} )
            if [ "${cspec#* -F }" != "$cspec" ]; then
                # complete -F <function>

                # get function name
                func=${cspec#*-F }
                func=${func%% *}

                if [[ ${#COMP_WORDS[@]} -ge 2 ]]; then
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}" "${COMP_WORDS[${#COMP_WORDS[@]}-2]}"
                else
                    $func $cmd "${COMP_WORDS[${#COMP_WORDS[@]}-1]}"
                fi

                # remove any \: generated by a command that doesn't
                # default to filenames or dirnames (e.g. sudo chown)
                # FIXME: I'm pretty sure this does not work!
                if [ "${cspec#*-o }" != "$cspec" ]; then
                    cspec=${cspec#*-o }
                    cspec=${cspec%% *}
                    if [[ "$cspec" != @(dir|file)names ]]; then
                        COMPREPLY=("${COMPREPLY[@]//\\\\:/:}")
                    else
                        _compopt_o_filenames
                    fi
                fi
            elif [ -n "$cspec" ]; then
                cspec=${cspec#complete};
                cspec=${cspec%%${cmd##*/}};
                COMPREPLY=( $( eval compgen "$cspec" -- "$cur" ) );
            fi
        elif [ ${#COMPREPLY[@]} -eq 0 ]; then
            _filedir
        fi
    fi
}
#complete -F _command aoss command do else eval exec ltrace nice nohup padsp \
#    then time tsocks vsound xargs

# Return true if the completion should be treated as running as root
_complete_as_root()
{
    [[ $EUID -eq 0 || ${root_command:-} ]]
}

_longopt()
{
    local cur prev split=false
    _get_comp_words_by_ref -n = cur prev

    _split_longopt && split=true

    case "$prev" in
        --*[Dd][Ii][Rr]*)
            _filedir -d
            return 0
            ;;
        --*[Ff][Ii][Ll][Ee]*|--*[Pp][Aa][Tt][Hh]*)
            _filedir
            return 0
            ;;
    esac

    $split && return 0

    if [[ "$cur" == -* ]]; then
        COMPREPLY=( $( compgen -W "$( $1 --help 2>&1 | \
            sed -ne 's/.*\(--[-A-Za-z0-9]\{1,\}\).*/\1/p' | sort -u )" \
            -- "$cur" ) )
    elif [[ "$1" == @(mk|rm)dir ]]; then
        _filedir -d
    else
        _filedir
    fi
}

# Local variables:
# mode: shell-script
# sh-basic-offset: 4
# sh-indent-comment: t
# indent-tabs-mode: nil
# End:
# ex: ts=4 sw=4 et filetype=sh
# bash completion for singularity                          -*- shell-script -*-

__singularity_debug()
{
    if [[ -n ${BASH_COMP_DEBUG_FILE:-} ]]; then
        echo "$*" >> "${BASH_COMP_DEBUG_FILE}"
    fi
}

# Homebrew on Macs have version 1.3 of bash-completion which doesn't include
# _init_completion. This is a very minimal version of that function.
__singularity_init_completion()
{
    COMPREPLY=()
    _get_comp_words_by_ref "$@" cur prev words cword
}

__singularity_index_of_word()
{
    local w word=$1
    shift
    index=0
    for w in "$@"; do
        [[ $w = "$word" ]] && return
        index=$((index+1))
    done
    index=-1
}

__singularity_contains_word()
{
    local w word=$1; shift
    for w in "$@"; do
        [[ $w = "$word" ]] && return
    done
    return 1
}

__singularity_handle_go_custom_completion()
{
    __singularity_debug "${FUNCNAME[0]}: cur is ${cur}, words[*] is ${words[*]}, #words[@] is ${#words[@]}"

    local shellCompDirectiveError=1
    local shellCompDirectiveNoSpace=2
    local shellCompDirectiveNoFileComp=4
    local shellCompDirectiveFilterFileExt=8
    local shellCompDirectiveFilterDirs=16

    local out requestComp lastParam lastChar comp directive args

    # Prepare the command to request completions for the program.
    # Calling ${words[0]} instead of directly singularity allows handling aliases
    args=("${words[@]:1}")
    # Disable ActiveHelp which is not supported for bash completion v1
    requestComp="SINGULARITY_ACTIVE_HELP=0 ${words[0]} __completeNoDesc ${args[*]}"

    lastParam=${words[$((${#words[@]}-1))]}
    lastChar=${lastParam:$((${#lastParam}-1)):1}
    __singularity_debug "${FUNCNAME[0]}: lastParam ${lastParam}, lastChar ${lastChar}"

    if [ -z "${cur}" ] && [ "${lastChar}" != "=" ]; then
        # If the last parameter is complete (there is a space following it)
        # We add an extra empty parameter so we can indicate this to the go method.
        __singularity_debug "${FUNCNAME[0]}: Adding extra empty parameter"
        requestComp="${requestComp} \"\""
    fi

    __singularity_debug "${FUNCNAME[0]}: calling ${requestComp}"
    # Use eval to handle any environment variables and such
    out=$(eval "${requestComp}" 2>/dev/null)

    # Extract the directive integer at the very end of the output following a colon (:)
    directive=${out##*:}
    # Remove the directive
    out=${out%:*}
    if [ "${directive}" = "${out}" ]; then
        # There is not directive specified
        directive=0
    fi
    __singularity_debug "${FUNCNAME[0]}: the completion directive is: ${directive}"
    __singularity_debug "${FUNCNAME[0]}: the completions are: ${out}"

    if [ $((directive & shellCompDirectiveError)) -ne 0 ]; then
        # Error code.  No completion.
        __singularity_debug "${FUNCNAME[0]}: received error from custom completion go code"
        return
    else
        if [ $((directive & shellCompDirectiveNoSpace)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __singularity_debug "${FUNCNAME[0]}: activating no space"
                compopt -o nospace
            fi
        fi
        if [ $((directive & shellCompDirectiveNoFileComp)) -ne 0 ]; then
            if [[ $(type -t compopt) = "builtin" ]]; then
                __singularity_debug "${FUNCNAME[0]}: activating no file completion"
                compopt +o default
            fi
        fi
    fi

    if [ $((directive & shellCompDirectiveFilterFileExt)) -ne 0 ]; then
        # File extension filtering
        local fullFilter filter filteringCmd
        # Do not use quotes around the $out variable or else newline
        # characters will be kept.
        for filter in ${out}; do
            fullFilter+="$filter|"
        done

        filteringCmd="_filedir $fullFilter"
        __singularity_debug "File filtering command: $filteringCmd"
        $filteringCmd
    elif [ $((directive & shellCompDirectiveFilterDirs)) -ne 0 ]; then
        # File completion for directories only
        local subdir
        # Use printf to strip any trailing newline
        subdir=$(printf "%s" "${out}")
        if [ -n "$subdir" ]; then
            __singularity_debug "Listing directories in $subdir"
            __singularity_handle_subdirs_in_dir_flag "$subdir"
        else
            __singularity_debug "Listing directories in ."
            _filedir -d
        fi
    else
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp")
        done < <(compgen -W "${out}" -- "$cur")
    fi
}

__singularity_handle_reply()
{
    __singularity_debug "${FUNCNAME[0]}"
    local comp
    case $cur in
        -*)
            if [[ $(type -t compopt) = "builtin" ]]; then
                compopt -o nospace
            fi
            local allflags
            if [ ${#must_have_one_flag[@]} -ne 0 ]; then
                allflags=("${must_have_one_flag[@]}")
            else
                allflags=("${flags[*]} ${two_word_flags[*]}")
            fi
            while IFS='' read -r comp; do
                COMPREPLY+=("$comp")
            done < <(compgen -W "${allflags[*]}" -- "$cur")
            if [[ $(type -t compopt) = "builtin" ]]; then
                [[ "${COMPREPLY[0]}" == *= ]] || compopt +o nospace
            fi

            # complete after --flag=abc
            if [[ $cur == *=* ]]; then
                if [[ $(type -t compopt) = "builtin" ]]; then
                    compopt +o nospace
                fi

                local index flag
                flag="${cur%=*}"
                __singularity_index_of_word "${flag}" "${flags_with_completion[@]}"
                COMPREPLY=()
                if [[ ${index} -ge 0 ]]; then
                    PREFIX=""
                    cur="${cur#*=}"
                    ${flags_completion[${index}]}
                    if [ -n "${ZSH_VERSION:-}" ]; then
                        # zsh completion needs --flag= prefix
                        eval "COMPREPLY=( \"\${COMPREPLY[@]/#/${flag}=}\" )"
                    fi
                fi
            fi

            if [[ -z "${flag_parsing_disabled}" ]]; then
                # If flag parsing is enabled, we have completed the flags and can return.
                # If flag parsing is disabled, we may not know all (or any) of the flags, so we fallthrough
                # to possibly call handle_go_custom_completion.
                return 0;
            fi
            ;;
    esac

    # check if we are handling a flag with special work handling
    local index
    __singularity_index_of_word "${prev}" "${flags_with_completion[@]}"
    if [[ ${index} -ge 0 ]]; then
        ${flags_completion[${index}]}
        return
    fi

    # we are parsing a flag and don't have a special handler, no completion
    if [[ ${cur} != "${words[cword]}" ]]; then
        return
    fi

    local completions
    completions=("${commands[@]}")
    if [[ ${#must_have_one_noun[@]} -ne 0 ]]; then
        completions+=("${must_have_one_noun[@]}")
    elif [[ -n "${has_completion_function}" ]]; then
        # if a go completion function is provided, defer to that function
        __singularity_handle_go_custom_completion
    fi
    if [[ ${#must_have_one_flag[@]} -ne 0 ]]; then
        completions+=("${must_have_one_flag[@]}")
    fi
    while IFS='' read -r comp; do
        COMPREPLY+=("$comp")
    done < <(compgen -W "${completions[*]}" -- "$cur")

    if [[ ${#COMPREPLY[@]} -eq 0 && ${#noun_aliases[@]} -gt 0 && ${#must_have_one_noun[@]} -ne 0 ]]; then
        while IFS='' read -r comp; do
            COMPREPLY+=("$comp")
        done < <(compgen -W "${noun_aliases[*]}" -- "$cur")
    fi

    if [[ ${#COMPREPLY[@]} -eq 0 ]]; then
        if declare -F __singularity_custom_func >/dev/null; then
            # try command name qualified custom func
            __singularity_custom_func
        else
            # otherwise fall back to unqualified for compatibility
            declare -F __custom_func >/dev/null && __custom_func
        fi
    fi

    # available in bash-completion >= 2, not always present on macOS
    if declare -F __ltrim_colon_completions >/dev/null; then
        __ltrim_colon_completions "$cur"
    fi

    # If there is only 1 completion and it is a flag with an = it will be completed
    # but we don't want a space after the =
    if [[ "${#COMPREPLY[@]}" -eq "1" ]] && [[ $(type -t compopt) = "builtin" ]] && [[ "${COMPREPLY[0]}" == --*= ]]; then
       compopt -o nospace
    fi
}

# The arguments should be in the form "ext1|ext2|extn"
__singularity_handle_filename_extension_flag()
{
    local ext="$1"
    _filedir "@(${ext})"
}

__singularity_handle_subdirs_in_dir_flag()
{
    local dir="$1"
    pushd "${dir}" >/dev/null 2>&1 && _filedir -d && popd >/dev/null 2>&1 || return
}

__singularity_handle_flag()
{
    __singularity_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    # if a command required a flag, and we found it, unset must_have_one_flag()
    local flagname=${words[c]}
    local flagvalue=""
    # if the word contained an =
    if [[ ${words[c]} == *"="* ]]; then
        flagvalue=${flagname#*=} # take in as flagvalue after the =
        flagname=${flagname%=*} # strip everything after the =
        flagname="${flagname}=" # but put the = back
    fi
    __singularity_debug "${FUNCNAME[0]}: looking for ${flagname}"
    if __singularity_contains_word "${flagname}" "${must_have_one_flag[@]}"; then
        must_have_one_flag=()
    fi

    # if you set a flag which only applies to this command, don't show subcommands
    if __singularity_contains_word "${flagname}" "${local_nonpersistent_flags[@]}"; then
      commands=()
    fi

    # keep flag value with flagname as flaghash
    # flaghash variable is an associative array which is only supported in bash > 3.
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        if [ -n "${flagvalue}" ] ; then
            flaghash[${flagname}]=${flagvalue}
        elif [ -n "${words[ $((c+1)) ]}" ] ; then
            flaghash[${flagname}]=${words[ $((c+1)) ]}
        else
            flaghash[${flagname}]="true" # pad "true" for bool flag
        fi
    fi

    # skip the argument to a two word flag
    if [[ ${words[c]} != *"="* ]] && __singularity_contains_word "${words[c]}" "${two_word_flags[@]}"; then
        __singularity_debug "${FUNCNAME[0]}: found a flag ${words[c]}, skip the next argument"
        c=$((c+1))
        # if we are looking for a flags value, don't show commands
        if [[ $c -eq $cword ]]; then
            commands=()
        fi
    fi

    c=$((c+1))

}

__singularity_handle_noun()
{
    __singularity_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    if __singularity_contains_word "${words[c]}" "${must_have_one_noun[@]}"; then
        must_have_one_noun=()
    elif __singularity_contains_word "${words[c]}" "${noun_aliases[@]}"; then
        must_have_one_noun=()
    fi

    nouns+=("${words[c]}")
    c=$((c+1))
}

__singularity_handle_command()
{
    __singularity_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"

    local next_command
    if [[ -n ${last_command} ]]; then
        next_command="_${last_command}_${words[c]//:/__}"
    else
        if [[ $c -eq 0 ]]; then
            next_command="_singularity_root_command"
        else
            next_command="_${words[c]//:/__}"
        fi
    fi
    c=$((c+1))
    __singularity_debug "${FUNCNAME[0]}: looking for ${next_command}"
    declare -F "$next_command" >/dev/null && $next_command
}

__singularity_handle_word()
{
    if [[ $c -ge $cword ]]; then
        __singularity_handle_reply
        return
    fi
    __singularity_debug "${FUNCNAME[0]}: c is $c words[c] is ${words[c]}"
    if [[ "${words[c]}" == -* ]]; then
        __singularity_handle_flag
    elif __singularity_contains_word "${words[c]}" "${commands[@]}"; then
        __singularity_handle_command
    elif [[ $c -eq 0 ]]; then
        __singularity_handle_command
    elif __singularity_contains_word "${words[c]}" "${command_aliases[@]}"; then
        # aliashash variable is an associative array which is only supported in bash > 3.
        if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
            words[c]=${aliashash[${words[c]}]}
            __singularity_handle_command
        else
            __singularity_handle_noun
        fi
    else
        __singularity_handle_noun
    fi
    __singularity_handle_word
}

_singularity_build()
{
    last_command="singularity_build"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--arch=")
    two_word_flags+=("--arch")
    flags+=("--arch-variant=")
    two_word_flags+=("--arch-variant")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--build-arg=")
    two_word_flags+=("--build-arg")
    flags+=("--build-arg-file=")
    two_word_flags+=("--build-arg-file")
    flags+=("--disable-cache")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--encrypt")
    flags+=("-e")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fix-perms")
    flags+=("--force")
    flags+=("-F")
    flags+=("--json")
    flags+=("--library=")
    two_word_flags+=("--library")
    flags+=("--mksquashfs-args=")
    two_word_flags+=("--mksquashfs-args")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--no-cleanup")
    flags+=("--no-https")
    flags+=("--notest")
    flags+=("-T")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--rocm")
    flags+=("--sandbox")
    flags+=("-s")
    flags+=("--section=")
    two_word_flags+=("--section")
    flags+=("--update")
    flags+=("-u")
    flags+=("--userns")
    flags+=("--warn-unused-build-args")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_cache_clean()
{
    last_command="singularity_cache_clean"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--days=")
    two_word_flags+=("--days")
    two_word_flags+=("-D")
    flags+=("--dry-run")
    flags+=("-n")
    flags+=("--force")
    flags+=("-f")
    flags+=("--type=")
    two_word_flags+=("--type")
    two_word_flags+=("-T")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_cache_list()
{
    last_command="singularity_cache_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--type=")
    two_word_flags+=("--type")
    two_word_flags+=("-T")
    flags+=("--verbose")
    flags+=("-v")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_cache()
{
    last_command="singularity_cache"

    command_aliases=()

    commands=()
    commands+=("clean")
    commands+=("list")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_capability_add()
{
    last_command="singularity_capability_add"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--group=")
    two_word_flags+=("--group")
    two_word_flags+=("-g")
    flags+=("--user=")
    two_word_flags+=("--user")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_capability_avail()
{
    last_command="singularity_capability_avail"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_capability_drop()
{
    last_command="singularity_capability_drop"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--group=")
    two_word_flags+=("--group")
    two_word_flags+=("-g")
    flags+=("--user=")
    two_word_flags+=("--user")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_capability_list()
{
    last_command="singularity_capability_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_capability()
{
    last_command="singularity_capability"

    command_aliases=()

    commands=()
    commands+=("add")
    commands+=("avail")
    commands+=("drop")
    commands+=("list")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_checkpoint_create()
{
    last_command="singularity_checkpoint_create"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_checkpoint_delete()
{
    last_command="singularity_checkpoint_delete"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_checkpoint_instance()
{
    last_command="singularity_checkpoint_instance"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_checkpoint_list()
{
    last_command="singularity_checkpoint_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_checkpoint()
{
    last_command="singularity_checkpoint"

    command_aliases=()

    commands=()
    commands+=("create")
    commands+=("delete")
    commands+=("instance")
    commands+=("list")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_config_fakeroot()
{
    last_command="singularity_config_fakeroot"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add")
    flags+=("-a")
    flags+=("--disable")
    flags+=("-d")
    flags+=("--enable")
    flags+=("-e")
    flags+=("--remove")
    flags+=("-r")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_config_global()
{
    last_command="singularity_config_global"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--dry-run")
    flags+=("-d")
    flags+=("--get")
    flags+=("-g")
    flags+=("--reset")
    flags+=("-r")
    flags+=("--set")
    flags+=("-s")
    flags+=("--unset")
    flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_config()
{
    last_command="singularity_config"

    command_aliases=()

    commands=()
    commands+=("fakeroot")
    commands+=("global")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_delete()
{
    last_command="singularity_delete"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--arch=")
    two_word_flags+=("--arch")
    two_word_flags+=("-A")
    flags+=("--force")
    flags+=("-F")
    flags+=("--library=")
    two_word_flags+=("--library")
    flags+=("--no-https")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_exec()
{
    last_command="singularity_exec"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add-caps=")
    two_word_flags+=("--add-caps")
    flags+=("--allow-setuid")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--apply-cgroups=")
    two_word_flags+=("--apply-cgroups")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--blkio-weight=")
    two_word_flags+=("--blkio-weight")
    flags+=("--blkio-weight-device=")
    two_word_flags+=("--blkio-weight-device")
    flags+=("--cleanenv")
    flags+=("-e")
    flags+=("--compat")
    flags+=("--contain")
    flags+=("-c")
    flags+=("--containall")
    flags+=("-C")
    flags+=("--cpu-shares=")
    two_word_flags+=("--cpu-shares")
    flags+=("--cpus=")
    two_word_flags+=("--cpus")
    flags+=("--cpuset-cpus=")
    two_word_flags+=("--cpuset-cpus")
    flags+=("--cpuset-mems=")
    two_word_flags+=("--cpuset-mems")
    flags+=("--cwd=")
    two_word_flags+=("--cwd")
    flags+=("--disable-cache")
    flags+=("--dns=")
    two_word_flags+=("--dns")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--drop-caps=")
    two_word_flags+=("--drop-caps")
    flags+=("--env=")
    two_word_flags+=("--env")
    flags+=("--env-file=")
    two_word_flags+=("--env-file")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fusemount=")
    two_word_flags+=("--fusemount")
    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")
    flags+=("--hostname=")
    two_word_flags+=("--hostname")
    flags+=("--ipc")
    flags+=("-i")
    flags+=("--keep-privs")
    flags+=("--memory=")
    two_word_flags+=("--memory")
    flags+=("--memory-reservation=")
    two_word_flags+=("--memory-reservation")
    flags+=("--memory-swap=")
    two_word_flags+=("--memory-swap")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--net")
    flags+=("-n")
    flags+=("--netns-path=")
    two_word_flags+=("--netns-path")
    flags+=("--network=")
    two_word_flags+=("--network")
    flags+=("--network-args=")
    two_word_flags+=("--network-args")
    flags+=("--no-eval")
    flags+=("--no-home")
    flags+=("--no-https")
    flags+=("--no-init")
    flags+=("--no-mount=")
    two_word_flags+=("--no-mount")
    flags+=("--no-pid")
    flags+=("--no-privs")
    flags+=("--no-umask")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--oom-kill-disable")
    flags+=("--overlay=")
    two_word_flags+=("--overlay")
    two_word_flags+=("-o")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--pid")
    flags+=("-p")
    flags+=("--pids-limit=")
    two_word_flags+=("--pids-limit")
    flags+=("--rocm")
    flags+=("--scratch=")
    two_word_flags+=("--scratch")
    two_word_flags+=("-S")
    flags+=("--security=")
    two_word_flags+=("--security")
    flags+=("--sharens")
    flags+=("--unsquash")
    flags+=("--userns")
    flags+=("-u")
    flags+=("--uts")
    flags+=("--workdir=")
    two_word_flags+=("--workdir")
    two_word_flags+=("-W")
    flags+=("--writable")
    flags+=("-w")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_inspect()
{
    last_command="singularity_inspect"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--all")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--deffile")
    flags+=("-d")
    flags+=("--environment")
    flags+=("-e")
    flags+=("--helpfile")
    flags+=("-H")
    flags+=("--json")
    flags+=("-j")
    flags+=("--labels")
    flags+=("-l")
    flags+=("--list-apps")
    flags+=("--runscript")
    flags+=("-r")
    flags+=("--startscript")
    flags+=("-s")
    flags+=("--test")
    flags+=("-t")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_instance_list()
{
    last_command="singularity_instance_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--all")
    flags+=("-a")
    flags+=("--json")
    flags+=("-j")
    flags+=("--logs")
    flags+=("-l")
    flags+=("--user=")
    two_word_flags+=("--user")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_instance_run()
{
    last_command="singularity_instance_run"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add-caps=")
    two_word_flags+=("--add-caps")
    flags+=("--allow-setuid")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--apply-cgroups=")
    two_word_flags+=("--apply-cgroups")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--blkio-weight=")
    two_word_flags+=("--blkio-weight")
    flags+=("--blkio-weight-device=")
    two_word_flags+=("--blkio-weight-device")
    flags+=("--boot")
    flags+=("--cleanenv")
    flags+=("-e")
    flags+=("--compat")
    flags+=("--contain")
    flags+=("-c")
    flags+=("--containall")
    flags+=("-C")
    flags+=("--cpu-shares=")
    two_word_flags+=("--cpu-shares")
    flags+=("--cpus=")
    two_word_flags+=("--cpus")
    flags+=("--cpuset-cpus=")
    two_word_flags+=("--cpuset-cpus")
    flags+=("--cpuset-mems=")
    two_word_flags+=("--cpuset-mems")
    flags+=("--disable-cache")
    flags+=("--dmtcp-launch=")
    two_word_flags+=("--dmtcp-launch")
    flags+=("--dmtcp-restart=")
    two_word_flags+=("--dmtcp-restart")
    flags+=("--dns=")
    two_word_flags+=("--dns")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--drop-caps=")
    two_word_flags+=("--drop-caps")
    flags+=("--env=")
    two_word_flags+=("--env")
    flags+=("--env-file=")
    two_word_flags+=("--env-file")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fusemount=")
    two_word_flags+=("--fusemount")
    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")
    flags+=("--hostname=")
    two_word_flags+=("--hostname")
    flags+=("--ipc")
    flags+=("-i")
    flags+=("--keep-privs")
    flags+=("--memory=")
    two_word_flags+=("--memory")
    flags+=("--memory-reservation=")
    two_word_flags+=("--memory-reservation")
    flags+=("--memory-swap=")
    two_word_flags+=("--memory-swap")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--net")
    flags+=("-n")
    flags+=("--netns-path=")
    two_word_flags+=("--netns-path")
    flags+=("--network=")
    two_word_flags+=("--network")
    flags+=("--network-args=")
    two_word_flags+=("--network-args")
    flags+=("--no-eval")
    flags+=("--no-home")
    flags+=("--no-https")
    flags+=("--no-init")
    flags+=("--no-mount=")
    two_word_flags+=("--no-mount")
    flags+=("--no-privs")
    flags+=("--no-umask")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--oom-kill-disable")
    flags+=("--overlay=")
    two_word_flags+=("--overlay")
    two_word_flags+=("-o")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--pid-file=")
    two_word_flags+=("--pid-file")
    flags+=("--pids-limit=")
    two_word_flags+=("--pids-limit")
    flags+=("--rocm")
    flags+=("--runscript-timeout=")
    two_word_flags+=("--runscript-timeout")
    flags+=("--scratch=")
    two_word_flags+=("--scratch")
    two_word_flags+=("-S")
    flags+=("--security=")
    two_word_flags+=("--security")
    flags+=("--unsquash")
    flags+=("--userns")
    flags+=("-u")
    flags+=("--uts")
    flags+=("--workdir=")
    two_word_flags+=("--workdir")
    two_word_flags+=("-W")
    flags+=("--writable")
    flags+=("-w")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_instance_start()
{
    last_command="singularity_instance_start"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add-caps=")
    two_word_flags+=("--add-caps")
    flags+=("--allow-setuid")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--apply-cgroups=")
    two_word_flags+=("--apply-cgroups")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--blkio-weight=")
    two_word_flags+=("--blkio-weight")
    flags+=("--blkio-weight-device=")
    two_word_flags+=("--blkio-weight-device")
    flags+=("--boot")
    flags+=("--cleanenv")
    flags+=("-e")
    flags+=("--compat")
    flags+=("--contain")
    flags+=("-c")
    flags+=("--containall")
    flags+=("-C")
    flags+=("--cpu-shares=")
    two_word_flags+=("--cpu-shares")
    flags+=("--cpus=")
    two_word_flags+=("--cpus")
    flags+=("--cpuset-cpus=")
    two_word_flags+=("--cpuset-cpus")
    flags+=("--cpuset-mems=")
    two_word_flags+=("--cpuset-mems")
    flags+=("--disable-cache")
    flags+=("--dmtcp-launch=")
    two_word_flags+=("--dmtcp-launch")
    flags+=("--dmtcp-restart=")
    two_word_flags+=("--dmtcp-restart")
    flags+=("--dns=")
    two_word_flags+=("--dns")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--drop-caps=")
    two_word_flags+=("--drop-caps")
    flags+=("--env=")
    two_word_flags+=("--env")
    flags+=("--env-file=")
    two_word_flags+=("--env-file")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fusemount=")
    two_word_flags+=("--fusemount")
    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")
    flags+=("--hostname=")
    two_word_flags+=("--hostname")
    flags+=("--ipc")
    flags+=("-i")
    flags+=("--keep-privs")
    flags+=("--memory=")
    two_word_flags+=("--memory")
    flags+=("--memory-reservation=")
    two_word_flags+=("--memory-reservation")
    flags+=("--memory-swap=")
    two_word_flags+=("--memory-swap")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--net")
    flags+=("-n")
    flags+=("--netns-path=")
    two_word_flags+=("--netns-path")
    flags+=("--network=")
    two_word_flags+=("--network")
    flags+=("--network-args=")
    two_word_flags+=("--network-args")
    flags+=("--no-eval")
    flags+=("--no-home")
    flags+=("--no-https")
    flags+=("--no-init")
    flags+=("--no-mount=")
    two_word_flags+=("--no-mount")
    flags+=("--no-privs")
    flags+=("--no-umask")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--oom-kill-disable")
    flags+=("--overlay=")
    two_word_flags+=("--overlay")
    two_word_flags+=("-o")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--pid-file=")
    two_word_flags+=("--pid-file")
    flags+=("--pids-limit=")
    two_word_flags+=("--pids-limit")
    flags+=("--rocm")
    flags+=("--scratch=")
    two_word_flags+=("--scratch")
    two_word_flags+=("-S")
    flags+=("--security=")
    two_word_flags+=("--security")
    flags+=("--unsquash")
    flags+=("--userns")
    flags+=("-u")
    flags+=("--uts")
    flags+=("--workdir=")
    two_word_flags+=("--workdir")
    two_word_flags+=("-W")
    flags+=("--writable")
    flags+=("-w")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_instance_stats()
{
    last_command="singularity_instance_stats"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--json")
    flags+=("-j")
    flags+=("--no-stream")
    flags+=("--user=")
    two_word_flags+=("--user")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_instance_stop()
{
    last_command="singularity_instance_stop"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--all")
    flags+=("-a")
    flags+=("--force")
    flags+=("-F")
    flags+=("--signal=")
    two_word_flags+=("--signal")
    two_word_flags+=("-s")
    flags+=("--timeout=")
    two_word_flags+=("--timeout")
    two_word_flags+=("-t")
    flags+=("--user=")
    two_word_flags+=("--user")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_instance()
{
    last_command="singularity_instance"

    command_aliases=()

    commands=()
    commands+=("list")
    commands+=("run")
    commands+=("start")
    commands+=("stats")
    commands+=("stop")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_export()
{
    last_command="singularity_key_export"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--armor")
    flags+=("-a")
    flags+=("--global")
    flags+=("-g")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--secret")
    flags+=("-s")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_import()
{
    last_command="singularity_key_import"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--global")
    flags+=("-g")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--new-password")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_list()
{
    last_command="singularity_key_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--global")
    flags+=("-g")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--secret")
    flags+=("-s")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_newpair()
{
    last_command="singularity_key_newpair"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--bit-length=")
    two_word_flags+=("--bit-length")
    two_word_flags+=("-b")
    flags+=("--comment=")
    two_word_flags+=("--comment")
    two_word_flags+=("-C")
    flags+=("--email=")
    two_word_flags+=("--email")
    two_word_flags+=("-E")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--name=")
    two_word_flags+=("--name")
    two_word_flags+=("-N")
    flags+=("--password=")
    two_word_flags+=("--password")
    two_word_flags+=("-P")
    flags+=("--push")
    flags+=("-U")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_pull()
{
    last_command="singularity_key_pull"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--global")
    flags+=("-g")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--url=")
    two_word_flags+=("--url")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_push()
{
    last_command="singularity_key_push"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--global")
    flags+=("-g")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--url=")
    two_word_flags+=("--url")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_remove()
{
    last_command="singularity_key_remove"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--both")
    flags+=("-b")
    flags+=("--global")
    flags+=("-g")
    flags+=("--keysdir=")
    two_word_flags+=("--keysdir")
    two_word_flags+=("-d")
    flags+=("--public")
    flags+=("-p")
    flags+=("--secret")
    flags+=("-s")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key_search()
{
    last_command="singularity_key_search"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--long-list")
    flags+=("-l")
    flags+=("--url=")
    two_word_flags+=("--url")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_key()
{
    last_command="singularity_key"

    command_aliases=()

    commands=()
    commands+=("export")
    commands+=("import")
    commands+=("list")
    commands+=("newpair")
    commands+=("pull")
    commands+=("push")
    commands+=("remove")
    commands+=("search")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_keyserver_add()
{
    last_command="singularity_keyserver_add"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--insecure")
    flags+=("-i")
    flags+=("--order=")
    two_word_flags+=("--order")
    two_word_flags+=("-o")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_keyserver_list()
{
    last_command="singularity_keyserver_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_keyserver_login()
{
    last_command="singularity_keyserver_login"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--password=")
    two_word_flags+=("--password")
    two_word_flags+=("-p")
    flags+=("--password-stdin")
    flags+=("--username=")
    two_word_flags+=("--username")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_keyserver_logout()
{
    last_command="singularity_keyserver_logout"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_keyserver_remove()
{
    last_command="singularity_keyserver_remove"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_keyserver()
{
    last_command="singularity_keyserver"

    command_aliases=()

    commands=()
    commands+=("add")
    commands+=("list")
    commands+=("login")
    commands+=("logout")
    commands+=("remove")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--config=")
    two_word_flags+=("--config")
    two_word_flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_attach()
{
    last_command="singularity_oci_attach"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_create()
{
    last_command="singularity_oci_create"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--bundle=")
    two_word_flags+=("--bundle")
    two_word_flags+=("-b")
    flags+=("--empty-process")
    flags+=("--log-format=")
    two_word_flags+=("--log-format")
    flags+=("--log-path=")
    two_word_flags+=("--log-path")
    two_word_flags+=("-l")
    flags+=("--pid-file=")
    two_word_flags+=("--pid-file")
    flags+=("--sync-socket=")
    two_word_flags+=("--sync-socket")
    two_word_flags+=("-s")

    must_have_one_flag=()
    must_have_one_flag+=("--bundle=")
    must_have_one_flag+=("-b")
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_delete()
{
    last_command="singularity_oci_delete"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_exec()
{
    last_command="singularity_oci_exec"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_kill()
{
    last_command="singularity_oci_kill"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--force")
    flags+=("-f")
    flags+=("--signal=")
    two_word_flags+=("--signal")
    two_word_flags+=("-s")
    flags+=("--timeout=")
    two_word_flags+=("--timeout")
    two_word_flags+=("-t")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_mount()
{
    last_command="singularity_oci_mount"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_pause()
{
    last_command="singularity_oci_pause"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_resume()
{
    last_command="singularity_oci_resume"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_run()
{
    last_command="singularity_oci_run"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--bundle=")
    two_word_flags+=("--bundle")
    two_word_flags+=("-b")
    flags+=("--log-format=")
    two_word_flags+=("--log-format")
    flags+=("--log-path=")
    two_word_flags+=("--log-path")
    two_word_flags+=("-l")
    flags+=("--pid-file=")
    two_word_flags+=("--pid-file")
    flags+=("--sync-socket=")
    two_word_flags+=("--sync-socket")
    two_word_flags+=("-s")

    must_have_one_flag=()
    must_have_one_flag+=("--bundle=")
    must_have_one_flag+=("-b")
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_start()
{
    last_command="singularity_oci_start"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_state()
{
    last_command="singularity_oci_state"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--sync-socket=")
    two_word_flags+=("--sync-socket")
    two_word_flags+=("-s")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_umount()
{
    last_command="singularity_oci_umount"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci_update()
{
    last_command="singularity_oci_update"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--from-file=")
    two_word_flags+=("--from-file")
    two_word_flags+=("-f")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_oci()
{
    last_command="singularity_oci"

    command_aliases=()

    commands=()
    commands+=("attach")
    commands+=("create")
    commands+=("delete")
    commands+=("exec")
    commands+=("kill")
    commands+=("mount")
    commands+=("pause")
    commands+=("resume")
    commands+=("run")
    commands+=("start")
    commands+=("state")
    commands+=("umount")
    commands+=("update")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_overlay_create()
{
    last_command="singularity_overlay_create"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--create-dir=")
    two_word_flags+=("--create-dir")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--size=")
    two_word_flags+=("--size")
    two_word_flags+=("-s")
    flags+=("--sparse")
    flags+=("-S")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_overlay()
{
    last_command="singularity_overlay"

    command_aliases=()

    commands=()
    commands+=("create")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_compile()
{
    last_command="singularity_plugin_compile"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--out=")
    two_word_flags+=("--out")
    two_word_flags+=("-o")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_create()
{
    last_command="singularity_plugin_create"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_disable()
{
    last_command="singularity_plugin_disable"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_enable()
{
    last_command="singularity_plugin_enable"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_inspect()
{
    last_command="singularity_plugin_inspect"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_install()
{
    last_command="singularity_plugin_install"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_list()
{
    last_command="singularity_plugin_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin_uninstall()
{
    last_command="singularity_plugin_uninstall"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_plugin()
{
    last_command="singularity_plugin"

    command_aliases=()

    commands=()
    commands+=("compile")
    commands+=("create")
    commands+=("disable")
    commands+=("enable")
    commands+=("inspect")
    commands+=("install")
    commands+=("list")
    commands+=("uninstall")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_pull()
{
    last_command="singularity_pull"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--arch=")
    two_word_flags+=("--arch")
    flags+=("--arch-variant=")
    two_word_flags+=("--arch-variant")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--dir=")
    two_word_flags+=("--dir")
    flags+=("--disable-cache")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--force")
    flags+=("-F")
    flags+=("--library=")
    two_word_flags+=("--library")
    flags+=("--no-cleanup")
    flags+=("--no-https")
    flags+=("--sandbox")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_push()
{
    last_command="singularity_push"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--allow-unsigned")
    flags+=("-U")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--description=")
    two_word_flags+=("--description")
    two_word_flags+=("-D")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--library=")
    two_word_flags+=("--library")
    flags+=("--no-https")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_registry_list()
{
    last_command="singularity_registry_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_registry_login()
{
    last_command="singularity_registry_login"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--password=")
    two_word_flags+=("--password")
    two_word_flags+=("-p")
    flags+=("--password-stdin")
    flags+=("--username=")
    two_word_flags+=("--username")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_registry_logout()
{
    last_command="singularity_registry_logout"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--authfile=")
    two_word_flags+=("--authfile")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_registry()
{
    last_command="singularity_registry"

    command_aliases=()

    commands=()
    commands+=("list")
    commands+=("login")
    commands+=("logout")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--config=")
    two_word_flags+=("--config")
    two_word_flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_add()
{
    last_command="singularity_remote_add"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--global")
    flags+=("-g")
    flags+=("--insecure")
    flags+=("-i")
    flags+=("--no-default")
    flags+=("-n")
    flags+=("--no-login")
    flags+=("--tokenfile=")
    two_word_flags+=("--tokenfile")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_get-login-password()
{
    last_command="singularity_remote_get-login-password"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_list()
{
    last_command="singularity_remote_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_login()
{
    last_command="singularity_remote_login"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--insecure")
    flags+=("-i")
    flags+=("--password=")
    two_word_flags+=("--password")
    two_word_flags+=("-p")
    flags+=("--password-stdin")
    flags+=("--tokenfile=")
    two_word_flags+=("--tokenfile")
    flags+=("--username=")
    two_word_flags+=("--username")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_logout()
{
    last_command="singularity_remote_logout"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_remove()
{
    last_command="singularity_remote_remove"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--global")
    flags+=("-g")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_status()
{
    last_command="singularity_remote_status"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote_use()
{
    last_command="singularity_remote_use"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--exclusive")
    flags+=("-e")
    flags+=("--global")
    flags+=("-g")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_remote()
{
    last_command="singularity_remote"

    command_aliases=()

    commands=()
    commands+=("add")
    commands+=("get-login-password")
    commands+=("list")
    commands+=("login")
    commands+=("logout")
    commands+=("remove")
    commands+=("status")
    commands+=("use")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--config=")
    two_word_flags+=("--config")
    two_word_flags+=("-c")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_run()
{
    last_command="singularity_run"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add-caps=")
    two_word_flags+=("--add-caps")
    flags+=("--allow-setuid")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--apply-cgroups=")
    two_word_flags+=("--apply-cgroups")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--blkio-weight=")
    two_word_flags+=("--blkio-weight")
    flags+=("--blkio-weight-device=")
    two_word_flags+=("--blkio-weight-device")
    flags+=("--cleanenv")
    flags+=("-e")
    flags+=("--compat")
    flags+=("--contain")
    flags+=("-c")
    flags+=("--containall")
    flags+=("-C")
    flags+=("--cpu-shares=")
    two_word_flags+=("--cpu-shares")
    flags+=("--cpus=")
    two_word_flags+=("--cpus")
    flags+=("--cpuset-cpus=")
    two_word_flags+=("--cpuset-cpus")
    flags+=("--cpuset-mems=")
    two_word_flags+=("--cpuset-mems")
    flags+=("--cwd=")
    two_word_flags+=("--cwd")
    flags+=("--disable-cache")
    flags+=("--dns=")
    two_word_flags+=("--dns")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--drop-caps=")
    two_word_flags+=("--drop-caps")
    flags+=("--env=")
    two_word_flags+=("--env")
    flags+=("--env-file=")
    two_word_flags+=("--env-file")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fusemount=")
    two_word_flags+=("--fusemount")
    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")
    flags+=("--hostname=")
    two_word_flags+=("--hostname")
    flags+=("--ipc")
    flags+=("-i")
    flags+=("--keep-privs")
    flags+=("--memory=")
    two_word_flags+=("--memory")
    flags+=("--memory-reservation=")
    two_word_flags+=("--memory-reservation")
    flags+=("--memory-swap=")
    two_word_flags+=("--memory-swap")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--net")
    flags+=("-n")
    flags+=("--netns-path=")
    two_word_flags+=("--netns-path")
    flags+=("--network=")
    two_word_flags+=("--network")
    flags+=("--network-args=")
    two_word_flags+=("--network-args")
    flags+=("--no-eval")
    flags+=("--no-home")
    flags+=("--no-https")
    flags+=("--no-init")
    flags+=("--no-mount=")
    two_word_flags+=("--no-mount")
    flags+=("--no-pid")
    flags+=("--no-privs")
    flags+=("--no-umask")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--oom-kill-disable")
    flags+=("--overlay=")
    two_word_flags+=("--overlay")
    two_word_flags+=("-o")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--pid")
    flags+=("-p")
    flags+=("--pids-limit=")
    two_word_flags+=("--pids-limit")
    flags+=("--rocm")
    flags+=("--runscript-timeout=")
    two_word_flags+=("--runscript-timeout")
    flags+=("--scratch=")
    two_word_flags+=("--scratch")
    two_word_flags+=("-S")
    flags+=("--security=")
    two_word_flags+=("--security")
    flags+=("--sharens")
    flags+=("--unsquash")
    flags+=("--userns")
    flags+=("-u")
    flags+=("--uts")
    flags+=("--workdir=")
    two_word_flags+=("--workdir")
    two_word_flags+=("-W")
    flags+=("--writable")
    flags+=("-w")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_run-help()
{
    last_command="singularity_run-help"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--app=")
    two_word_flags+=("--app")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_search()
{
    last_command="singularity_search"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--arch=")
    two_word_flags+=("--arch")
    flags+=("--library=")
    two_word_flags+=("--library")
    flags+=("--signed")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_shell()
{
    last_command="singularity_shell"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add-caps=")
    two_word_flags+=("--add-caps")
    flags+=("--allow-setuid")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--apply-cgroups=")
    two_word_flags+=("--apply-cgroups")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--blkio-weight=")
    two_word_flags+=("--blkio-weight")
    flags+=("--blkio-weight-device=")
    two_word_flags+=("--blkio-weight-device")
    flags+=("--cleanenv")
    flags+=("-e")
    flags+=("--compat")
    flags+=("--contain")
    flags+=("-c")
    flags+=("--containall")
    flags+=("-C")
    flags+=("--cpu-shares=")
    two_word_flags+=("--cpu-shares")
    flags+=("--cpus=")
    two_word_flags+=("--cpus")
    flags+=("--cpuset-cpus=")
    two_word_flags+=("--cpuset-cpus")
    flags+=("--cpuset-mems=")
    two_word_flags+=("--cpuset-mems")
    flags+=("--cwd=")
    two_word_flags+=("--cwd")
    flags+=("--disable-cache")
    flags+=("--dns=")
    two_word_flags+=("--dns")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--drop-caps=")
    two_word_flags+=("--drop-caps")
    flags+=("--env=")
    two_word_flags+=("--env")
    flags+=("--env-file=")
    two_word_flags+=("--env-file")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fusemount=")
    two_word_flags+=("--fusemount")
    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")
    flags+=("--hostname=")
    two_word_flags+=("--hostname")
    flags+=("--ipc")
    flags+=("-i")
    flags+=("--keep-privs")
    flags+=("--memory=")
    two_word_flags+=("--memory")
    flags+=("--memory-reservation=")
    two_word_flags+=("--memory-reservation")
    flags+=("--memory-swap=")
    two_word_flags+=("--memory-swap")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--net")
    flags+=("-n")
    flags+=("--netns-path=")
    two_word_flags+=("--netns-path")
    flags+=("--network=")
    two_word_flags+=("--network")
    flags+=("--network-args=")
    two_word_flags+=("--network-args")
    flags+=("--no-eval")
    flags+=("--no-home")
    flags+=("--no-https")
    flags+=("--no-init")
    flags+=("--no-mount=")
    two_word_flags+=("--no-mount")
    flags+=("--no-pid")
    flags+=("--no-privs")
    flags+=("--no-umask")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--oom-kill-disable")
    flags+=("--overlay=")
    two_word_flags+=("--overlay")
    two_word_flags+=("-o")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--pid")
    flags+=("-p")
    flags+=("--pids-limit=")
    two_word_flags+=("--pids-limit")
    flags+=("--rocm")
    flags+=("--scratch=")
    two_word_flags+=("--scratch")
    two_word_flags+=("-S")
    flags+=("--security=")
    two_word_flags+=("--security")
    flags+=("--sharens")
    flags+=("--shell=")
    two_word_flags+=("--shell")
    two_word_flags+=("-s")
    flags+=("--unsquash")
    flags+=("--userns")
    flags+=("-u")
    flags+=("--uts")
    flags+=("--workdir=")
    two_word_flags+=("--workdir")
    two_word_flags+=("-W")
    flags+=("--writable")
    flags+=("-w")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_add()
{
    last_command="singularity_sif_add"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--alignment=")
    two_word_flags+=("--alignment")
    flags+=("--datatype=")
    two_word_flags+=("--datatype")
    flags+=("--filename=")
    two_word_flags+=("--filename")
    flags+=("--groupid=")
    two_word_flags+=("--groupid")
    flags+=("--link=")
    two_word_flags+=("--link")
    flags+=("--partarch=")
    two_word_flags+=("--partarch")
    flags+=("--partfs=")
    two_word_flags+=("--partfs")
    flags+=("--parttype=")
    two_word_flags+=("--parttype")
    flags+=("--sbomformat=")
    two_word_flags+=("--sbomformat")
    flags+=("--signentity=")
    two_word_flags+=("--signentity")
    flags+=("--signhash=")
    two_word_flags+=("--signhash")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_del()
{
    last_command="singularity_sif_del"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_dump()
{
    last_command="singularity_sif_dump"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_header()
{
    last_command="singularity_sif_header"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_info()
{
    last_command="singularity_sif_info"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_list()
{
    last_command="singularity_sif_list"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_new()
{
    last_command="singularity_sif_new"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif_setprim()
{
    last_command="singularity_sif_setprim"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sif()
{
    last_command="singularity_sif"

    command_aliases=()

    commands=()
    commands+=("add")
    commands+=("del")
    commands+=("dump")
    commands+=("header")
    commands+=("info")
    commands+=("list")
    commands+=("new")
    commands+=("setprim")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_sign()
{
    last_command="singularity_sign"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--group-id=")
    two_word_flags+=("--group-id")
    two_word_flags+=("-g")
    flags+=("--key=")
    two_word_flags+=("--key")
    flags+=("--keyidx=")
    two_word_flags+=("--keyidx")
    two_word_flags+=("-k")
    flags+=("--sif-id=")
    two_word_flags+=("--sif-id")
    two_word_flags+=("-i")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_test()
{
    last_command="singularity_test"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--add-caps=")
    two_word_flags+=("--add-caps")
    flags+=("--allow-setuid")
    flags+=("--app=")
    two_word_flags+=("--app")
    flags+=("--apply-cgroups=")
    two_word_flags+=("--apply-cgroups")
    flags+=("--authfile=")
    two_word_flags+=("--authfile")
    flags+=("--bind=")
    two_word_flags+=("--bind")
    two_word_flags+=("-B")
    flags+=("--blkio-weight=")
    two_word_flags+=("--blkio-weight")
    flags+=("--blkio-weight-device=")
    two_word_flags+=("--blkio-weight-device")
    flags+=("--cleanenv")
    flags+=("-e")
    flags+=("--compat")
    flags+=("--contain")
    flags+=("-c")
    flags+=("--containall")
    flags+=("-C")
    flags+=("--cpu-shares=")
    two_word_flags+=("--cpu-shares")
    flags+=("--cpus=")
    two_word_flags+=("--cpus")
    flags+=("--cpuset-cpus=")
    two_word_flags+=("--cpuset-cpus")
    flags+=("--cpuset-mems=")
    two_word_flags+=("--cpuset-mems")
    flags+=("--cwd=")
    two_word_flags+=("--cwd")
    flags+=("--disable-cache")
    flags+=("--dns=")
    two_word_flags+=("--dns")
    flags+=("--docker-host=")
    two_word_flags+=("--docker-host")
    flags+=("--docker-login")
    flags+=("--drop-caps=")
    two_word_flags+=("--drop-caps")
    flags+=("--env=")
    two_word_flags+=("--env")
    flags+=("--env-file=")
    two_word_flags+=("--env-file")
    flags+=("--fakeroot")
    flags+=("-f")
    flags+=("--fusemount=")
    two_word_flags+=("--fusemount")
    flags+=("--home=")
    two_word_flags+=("--home")
    two_word_flags+=("-H")
    flags+=("--hostname=")
    two_word_flags+=("--hostname")
    flags+=("--ipc")
    flags+=("-i")
    flags+=("--keep-privs")
    flags+=("--memory=")
    two_word_flags+=("--memory")
    flags+=("--memory-reservation=")
    two_word_flags+=("--memory-reservation")
    flags+=("--memory-swap=")
    two_word_flags+=("--memory-swap")
    flags+=("--mount=")
    two_word_flags+=("--mount")
    flags+=("--net")
    flags+=("-n")
    flags+=("--netns-path=")
    two_word_flags+=("--netns-path")
    flags+=("--network=")
    two_word_flags+=("--network")
    flags+=("--network-args=")
    two_word_flags+=("--network-args")
    flags+=("--no-eval")
    flags+=("--no-home")
    flags+=("--no-https")
    flags+=("--no-init")
    flags+=("--no-mount=")
    two_word_flags+=("--no-mount")
    flags+=("--no-pid")
    flags+=("--no-privs")
    flags+=("--no-umask")
    flags+=("--nv")
    flags+=("--nvccli")
    flags+=("--oom-kill-disable")
    flags+=("--overlay=")
    two_word_flags+=("--overlay")
    two_word_flags+=("-o")
    flags+=("--passphrase")
    flags+=("--pem-path=")
    two_word_flags+=("--pem-path")
    flags+=("--pid")
    flags+=("-p")
    flags+=("--pids-limit=")
    two_word_flags+=("--pids-limit")
    flags+=("--rocm")
    flags+=("--scratch=")
    two_word_flags+=("--scratch")
    two_word_flags+=("-S")
    flags+=("--security=")
    two_word_flags+=("--security")
    flags+=("--sharens")
    flags+=("--unsquash")
    flags+=("--userns")
    flags+=("-u")
    flags+=("--uts")
    flags+=("--workdir=")
    two_word_flags+=("--workdir")
    two_word_flags+=("-W")
    flags+=("--writable")
    flags+=("-w")
    flags+=("--writable-tmpfs")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_verify()
{
    last_command="singularity_verify"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--all")
    flags+=("-a")
    flags+=("--certificate=")
    two_word_flags+=("--certificate")
    flags+=("--certificate-intermediates=")
    two_word_flags+=("--certificate-intermediates")
    flags+=("--certificate-roots=")
    two_word_flags+=("--certificate-roots")
    flags+=("--group-id=")
    two_word_flags+=("--group-id")
    two_word_flags+=("-g")
    flags+=("--json")
    flags+=("-j")
    flags+=("--key=")
    two_word_flags+=("--key")
    flags+=("--legacy-insecure")
    flags+=("--local")
    flags+=("-l")
    flags+=("--ocsp-verify")
    flags+=("--sif-id=")
    two_word_flags+=("--sif-id")
    two_word_flags+=("-i")
    flags+=("--url=")
    two_word_flags+=("--url")
    two_word_flags+=("-u")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_version()
{
    last_command="singularity_version"

    command_aliases=()

    commands=()

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()


    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

_singularity_root_command()
{
    last_command="singularity"

    command_aliases=()

    commands=()
    commands+=("build")
    commands+=("cache")
    commands+=("capability")
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        command_aliases+=("caps")
        aliashash["caps"]="capability"
    fi
    commands+=("checkpoint")
    commands+=("config")
    commands+=("delete")
    commands+=("exec")
    commands+=("inspect")
    commands+=("instance")
    commands+=("key")
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        command_aliases+=("keys")
        aliashash["keys"]="key"
    fi
    commands+=("keyserver")
    commands+=("oci")
    commands+=("overlay")
    commands+=("plugin")
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        command_aliases+=("plugins")
        aliashash["plugins"]="plugin"
    fi
    commands+=("pull")
    commands+=("push")
    commands+=("registry")
    commands+=("remote")
    commands+=("run")
    commands+=("run-help")
    commands+=("search")
    commands+=("shell")
    commands+=("sif")
    if [[ -z "${BASH_VERSION:-}" || "${BASH_VERSINFO[0]:-}" -gt 3 ]]; then
        command_aliases+=("siftool")
        aliashash["siftool"]="sif"
    fi
    commands+=("sign")
    commands+=("test")
    commands+=("verify")
    commands+=("version")

    flags=()
    two_word_flags=()
    local_nonpersistent_flags=()
    flags_with_completion=()
    flags_completion=()

    flags+=("--build-config")
    flags+=("--config=")
    two_word_flags+=("--config")
    two_word_flags+=("-c")
    flags+=("--debug")
    flags+=("-d")
    flags+=("--nocolor")
    flags+=("--quiet")
    flags+=("-q")
    flags+=("--silent")
    flags+=("-s")
    flags+=("--verbose")
    flags+=("-v")

    must_have_one_flag=()
    must_have_one_noun=()
    noun_aliases=()
}

__start_singularity()
{
    local cur prev words cword split
    declare -A flaghash 2>/dev/null || :
    declare -A aliashash 2>/dev/null || :
    if declare -F _init_completion >/dev/null 2>&1; then
        _init_completion -s || return
    else
        __singularity_init_completion -n "=" || return
    fi

    local c=0
    local flag_parsing_disabled=
    local flags=()
    local two_word_flags=()
    local local_nonpersistent_flags=()
    local flags_with_completion=()
    local flags_completion=()
    local commands=("singularity")
    local command_aliases=()
    local must_have_one_flag=()
    local must_have_one_noun=()
    local has_completion_function=""
    local last_command=""
    local nouns=()
    local noun_aliases=()

    __singularity_handle_word
}

if [[ $(type -t compopt) = "builtin" ]]; then
    complete -o default -F __start_singularity singularity
else
    complete -o default -o nospace -F __start_singularity singularity
fi

# ex: ts=4 sw=4 et filetype=sh
module lost mpavich/3.0

Modules based on Lua: Version 8.7.53 2024-10-12 19:57 -05:00
    by Robert McLay mclay@tacc.utexas.edu

module [options] sub-command [args ...]

Help sub-commands:


  help                              prints this message
  help                module [...]  print help message from module(s)

Loading/Unloading sub-commands:


  load | add          module [...]  load module(s)
  try-load | try-add  module [...]  Add module(s), do not complain if not
                                    found
  del | unload        module [...]  Remove module(s), do not complain if not
                                    found
  swap | sw | switch  m1 m2         unload m1 and load m2
  purge                             unload all modules
  refresh                           reload aliases from current list of
                                    modules.
  update                            reload all currently loaded modules.

Listing / Searching sub-commands:


  list                              List loaded modules
  list                s1 s2 ...     List loaded modules that match the
                                    pattern
  avail | av                        List available modules
  avail | av          string        List available modules that contain
                                    "string".
  category | cat                    List all categories
  category | cat      s1 s2 ...     List all categories that match the
                                    pattern and display their modules
  overview | ov                     List all available modules by short
                                    names with number of versions
  overview | ov       string        List available modules by short names
                                    with number of versions that contain
                                    "string"
  spider                            List all possible modules
  spider              module        List all possible version of that module
                                    file
  spider              string        List all module that contain the
                                    "string".
  spider              name/version  Detailed information about that version
                                    of the module.
  whatis              module        Print whatis information about module
  keyword | key       string        Search all name and whatis that contain
                                    "string".

Searching with Lmod:


  All searching (spider, list, avail, keyword) support regular expressions:
  

  -r spider           '^p'          Finds all the modules that start with
                                    `p' or `P'
  -r spider           mpi           Finds all modules that have "mpi" in
                                    their name.
  -r spider           'mpi$         Finds all modules that end with "mpi" in
                                    their name.

Handling a collection of modules:


  save | s                          Save the current list of modules to a
                                    user defined "default" collection.
  save | s            name          Save the current list of modules to
                                    "name" collection.
  reset                             The same as "restore system"
  restore | r                       Restore modules from the user's
                                    "default" or system default.
  restore | r         name          Restore modules from "name" collection.
  restore             system        Restore module state to system defaults.
  savelist                          List of saved collections.
  describe | mcc      name          Describe the contents of a module
                                    collection.
  disable             name          Disable (i.e. remove) a collection.

Deprecated commands:


  getdefault          [name]        load name collection of modules or
                                    user's "default" if no name given.
                                    ===> Use "restore" instead <====
  setdefault          [name]        Save current list of modules to name if
                                    given, otherwise save as the default
                                    list for you the user.
                                    ===> Use "save" instead. <====

Miscellaneous sub-commands:


  is-loaded           modulefile    return a true status if module is loaded
  is-avail            modulefile    return a true status if module can be
                                    loaded
  show                modulefile    show the commands in the module file.
  use [-a]            path          Prepend or Append path to MODULEPATH.
  unuse               path          remove path from MODULEPATH.
  tablelist                         output list of active modules as a lua
                                    table.

Important Environment Variables:


  LMOD_COLORIZE                     If defined to be "YES" then Lmod prints
                                    properties and warning in color.


Lmod Web Sites

  Documentation:    https://lmod.readthedocs.org
  GitHub:           https://github.com/TACC/Lmod
  SourceForge:      https://lmod.sf.net
  TACC Homepage:    https://www.tacc.utexas.edu/research-development/tacc-projects/lmod

  To report a bug please read https://lmod.readthedocs.io/en/latest/075_bug_reporting.html

